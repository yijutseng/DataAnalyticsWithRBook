[
["index.html", "資料科學與R語言", " 資料科學與R語言 曾意儒 Yi-Ju Tseng 2020-07-20 本書介紹如何使用R語言完成資料讀取 (檔案、透過API擷取或爬蟲)、資料清洗與處理、探索式資料分析、資料視覺化、互動式資料呈現 (搭配Shiny) 與資料探勘等，並介紹R與Hadoop Ecosystems介接方法。 資料探勘章節尚未完成，epub版本格式微調中。 如要一次安裝所有本書會使用到的套件，可在R內執行以下程式碼： install.packages(&quot;devtools&quot;) devtools::install_github(&quot;yijutseng/DataAnalyticsWithRBook&quot;) 本書為長庚大學資訊管理學系 大數據分析方法課程教學使用書籍，並可搭配YouTube平台上的教學影片參考使用，影片閱讀清單詳見本書最末章節Ch 13 教學影片資訊。 如果您想修改文字或範例，歡迎透過此連結或是透過GitHub issue提供建議與回饋。 本書程式碼執行環境： sessionInfo() ## R version 4.0.1 (2020-06-06) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 18363) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Chinese (Traditional)_Taiwan.950 ## [2] LC_CTYPE=Chinese (Traditional)_Taiwan.950 ## [3] LC_MONETARY=Chinese (Traditional)_Taiwan.950 ## [4] LC_NUMERIC=C ## [5] LC_TIME=Chinese (Traditional)_Taiwan.950 ## ## attached base packages: ## [1] grid stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] tidyr_1.1.0 curl_4.3 treemap_2.4-2 ## [4] purrr_0.3.4 caret_6.0-86 lattice_0.20-41 ## [7] MASS_7.3-51.6 arulesViz_1.3-3 arules_1.6-6 ## [10] Matrix_1.2-18 fields_10.3 maps_3.3.0 ## [13] spam_2.5-1 dotCall64_1.0-0 rpart.plot_3.0.8 ## [16] rpart_4.1-15 googleVis_0.6.6 ggvis_0.4.5 ## [19] plotly_4.9.2.1 shiny_1.4.0.2 treemapify_2.5.3 ## [22] WDI_2.7.1 choroplethrMaps_1.0.1 choroplethr_3.6.3 ## [25] acs_2.1.4 ggmap_3.0.0.902 maptools_1.0-1 ## [28] rgeos_0.5-3 rgdal_1.5-12 sp_1.4-2 ## [31] rvest_0.3.5 xml2_1.3.2 Rfacebook_0.6.15 ## [34] httpuv_1.5.4 rjson_0.2.20 XML_3.99-0.3 ## [37] jsonlite_1.6.1 httr_1.4.1 readxl_1.3.1 ## [40] readr_1.3.1 SportsAnalytics_0.2 reshape2_1.4.4 ## [43] stringr_1.4.0 data.table_1.12.8 RCurl_1.98-1.2 ## [46] rmarkdown_2.3 knitr_1.28 bookdown_0.20 ## [49] bit64_0.9-7.1 bit_1.1-15.2 lubridate_1.7.9 ## [52] dplyr_1.0.0 ggplot2_3.3.1 ## ## loaded via a namespace (and not attached): ## [1] uuid_0.1-4 backports_1.1.7 Hmisc_4.4-0 ## [4] igraph_1.2.5 plyr_1.8.6 lazyeval_0.2.2 ## [7] splines_4.0.1 gridBase_0.4-7 digest_0.6.25 ## [10] foreach_1.5.0 htmltools_0.4.0 viridis_0.5.1 ## [13] gdata_2.18.0 magrittr_1.5 checkmate_2.0.0 ## [16] cluster_2.1.0 gclus_1.3.2 recipes_0.1.12 ## [19] ggfittext_0.9.0 gower_0.2.1 jpeg_0.1-8.1 ## [22] colorspace_1.4-1 rappdirs_0.3.1 xfun_0.14 ## [25] crayon_1.3.4 zoo_1.8-8 survival_3.1-12 ## [28] tigris_1.0 iterators_1.0.12 glue_1.4.1 ## [31] registry_0.5-1 gtable_0.3.0 ipred_0.9-9 ## [34] scales_1.1.1 DBI_1.1.0 Rcpp_1.0.4.6 ## [37] viridisLite_0.3.0 xtable_1.8-4 htmlTable_2.0.1 ## [40] units_0.6-7 foreign_0.8-80 Formula_1.2-3 ## [43] stats4_4.0.1 lava_1.6.7 prodlim_2019.11.13 ## [46] DT_0.13 vcd_1.4-7 htmlwidgets_1.5.1 ## [49] gplots_3.0.3 RColorBrewer_1.1-2 acepack_1.4.1 ## [52] ellipsis_0.3.1 pkgconfig_2.0.3 nnet_7.3-14 ## [55] RJSONIO_1.3-1.4 tidyselect_1.1.0 rlang_0.4.6 ## [58] later_1.1.0.1 visNetwork_2.0.9 munsell_0.5.0 ## [61] cellranger_1.1.0 tools_4.0.1 generics_0.0.2 ## [64] evaluate_0.14 fastmap_1.0.1 yaml_2.2.1 ## [67] ModelMetrics_1.2.2.2 caTools_1.18.0 RgoogleMaps_1.4.5.3 ## [70] dendextend_1.13.4 packrat_0.5.0 nlme_3.1-148 ## [73] mime_0.9 compiler_4.0.1 rstudioapi_0.11 ## [76] png_0.1-7 e1071_1.7-3 tibble_3.0.1 ## [79] stringi_1.4.6 classInt_0.4-3 vctrs_0.3.1 ## [82] pillar_1.4.4 lifecycle_0.2.0 lmtest_0.9-37 ## [85] bitops_1.0-6 seriation_1.2-8 R6_2.4.1 ## [88] latticeExtra_0.6-29 promises_1.1.1 TSP_1.1-10 ## [91] KernSmooth_2.23-17 gridExtra_2.3 codetools_0.2-16 ## [94] gtools_3.8.2 assertthat_0.2.1 withr_2.2.0 ## [97] hms_0.5.3 timeDate_3043.102 class_7.3-17 ## [100] pROC_1.16.2 sf_0.9-5 scatterplot3d_0.3-41 ## [103] base64enc_0.1-3 本書使用套件版本： pkgInfo&lt;-lapply(pkg, packageDescription, fields = c(&quot;Package&quot;, &quot;Version&quot;)) knitr::kable(data.frame(Package=sapply(pkgInfo, `[[`, 1), Version=sapply(pkgInfo, `[[`, 2))) Package Version ggplot2 3.3.1 dplyr 1.0.0 lubridate 1.7.9 bit64 0.9-7.1 bookdown 0.20 knitr 1.28 rmarkdown 2.3 RCurl 1.98-1.2 data.table 1.12.8 stringr 1.4.0 reshape2 1.4.4 SportsAnalytics 0.2 readr 1.3.1 readxl 1.3.1 httr 1.4.1 jsonlite 1.6.1 XML 3.99-0.3 Rfacebook 0.6.15 rvest 0.3.5 rgdal 1.5-12 rgeos 0.5-3 maptools 1.0-1 ggmap 3.0.0.902 choroplethr 3.6.3 choroplethrMaps 1.0.1 WDI 2.7.1 treemapify 2.5.3 shiny 1.4.0.2 plotly 4.9.2.1 ggvis 0.4.5 googleVis 0.6.6 rpart 4.1-15 rpart.plot 3.0.8 fields 10.3 arules 1.6-6 datasets 4.0.1 arulesViz 1.3-3 MASS 7.3-51.6 caret 6.0-86 purrr 0.3.4 treemap 2.4-2 curl 4.3 xml2 1.3.2 tidyr 1.1.0 本著作係採用創用 CC 姓名標示-非商業性-禁止改作 3.0 台灣 授權條款授權。 "],
["intro.html", "1 R語言101 1.1 什麼是R語言 1.2 函數使用 1.3 變數設定 1.4 執行視窗 1.5 資料型態 1.6 基本運算子 1.7 錯誤訊息 1.8 Help", " 1 R語言101 本章節介紹學習R語言的基本知識，包括基本指令操作、運算子介紹等。 1.1 什麼是R語言 R語言是一種自由軟體程式語言，主要用於資料分析與統計運算，2000年時終於發表R 1.0.0，有關R語言的發展歷史可參考維基百科。基本的R軟體已經內建多種統計及分析功能，其餘功能可以透過安裝套件（Packages）加載，眾多的套件使R的使用者可以【站在巨人的肩膀上(Standing on the shoulders of giants (Hal R. Varian, Google))】做資料分析，截至2017年1月為止，R軟體可另外安裝的套件數目共有10,000個以上 (R Studio報導)。常用的套件清單可參考各項網路資訊，如R Studio的整理：Quick list of useful R packages 安裝套件Package的方法如下： install.packages(&quot;套件名稱&quot;) 值得注意的是，套件名稱需要加上雙引號，舉例來說，若要安裝ggplot2套件，則要在R的Console視窗內輸入： install.packages(&quot;ggplot2&quot;) 若要載入已安裝的套件，則輸入library(套件名稱)，範例： library(ggplot2) 載入已安裝的套件時，可以不用在套件名稱前後加雙引號，但也可以加 （參考資料）。 1.2 函數使用 在R中有許多內建函數，安裝套件後各套件也會提供各式各樣寫好的函數，函數使用方式為函數名稱(參數1,參數2,....)，以計算平均數為例，可使用mean()函數，範例如下: mean(c(1,2,3,4,5,6)) ##計算1~6的平均數 ## [1] 3.5 若想知道各函數所需參數，可使用?函數名稱觀看函數作者所撰寫的說明文件 ?mean 除非有指定參數名稱，函數的參數設定有順序性，如序列產生函數seq()，參數順序為from, to, by，代表序列起點、序列終點，以及相隔單位。 seq(from=1,to=9,by=2)#1~9，每隔2產生一數字 ## [1] 1 3 5 7 9 seq(1,9,2)#按照順序輸入參數，可省去參數名稱 ## [1] 1 3 5 7 9 seq(by=2,to=9,from=1)#若不想照順序輸入參數，需要指定參數名稱 ## [1] 1 3 5 7 9 1.3 變數設定 在開始深入學習R語言之前，首要任務是學習最基本的R程式碼：變數設定，在R語言中，主要使用&lt;-設定變數，設定方法為：變數名稱&lt;-變數內容(值)，雖然變數名稱可依箭頭方向放置於左側&lt;-或右側-&gt;，但為方便閱讀，變數名稱多放置於左側。 a&lt;-1 2-&gt;b a ## [1] 1 b ## [1] 2 R語言也接受使用=設定變數，此時變數名稱必須在左側，如：變數名稱=變數內容 c=1 c ## [1] 1 除了變數設定外，str()函數也為常用基本函數，str()用在檢查與總覽各類變數型態。 d&lt;-3 str(d) ## num 3 變數的命名有以下規則: 不可使用保留字，如break, else, FALSE, for, function, if, Inf, NA, NaN, next, repeat, return, TRUE, while等 開頭只能是英文字，或 . 大小寫敏感 1.4 執行視窗 R是可直譯的語言，也就是說，可以在執行視窗(Console)直接打程式碼，在視窗出現&gt;時，表示可輸入指令，若視窗出現+時，表示前面的程式碼還沒打完，必須鍵入完整的程式碼讓R執行。 1.5 資料型態 在R語言中，常用的資料型態包括數值 (numeric)、字串 (character)、布林變數 (logic)以及日期 (Date)等。 1.5.1 數值 numeric 數值包括整數（沒有小數點）與浮點數（有小數點）的數值 num1&lt;-100 num2&lt;-1000.001 值得注意的是，若數值長度超過 2^53，必須導入bit64 package (Oehlschlagel 2020)，將數值長度上限提高為2^63，才能表示完整數值 print(2^53, digits=20) ## [1] 9007199254740992 print(2^53+1, digits=20) # +1後，數值仍與2^53相同 ## [1] 9007199254740992 library(bit64) # 導入bit64 package print(as.integer64(2)^53, digits=20) ## integer64 ## [1] 9007199254740992 print(as.integer64(2)^53+1, digits=20)# 導入bit64後，可得正確答案 ## integer64 ## [1] 9007199254740993 1.5.2 字串 character 用雙引號\"框起的文字會被儲存為字串格式，若在數字前後加上雙引號，數字也會被儲存為文字形式，無法進行數值的加減乘除等運算。 char1&lt;-&quot;abcTest&quot; char2&lt;-&quot;100&quot; char3&lt;-&quot;200&quot; #char2+char3 #會輸出Error message: non-numeric argument to binary operator 1.5.3 布林變數 logic 用於邏輯判斷，可使用大寫TRUE或T代表真，大寫FALSE或F代表假。 boolT&lt;-TRUE boolT1&lt;-T boolF&lt;-FALSE boolF1&lt;-F 1.5.4 日期 (Date) 用於表示日期，於資料分析中常用，使用Sys.Date()指令可得系統日期。 dateBook&lt;-Sys.Date() dateBook ## [1] &quot;2020-07-20&quot; 日期與字串的相關轉換操作可考慮使用簡單易懂的lubridate(Spinu, Grolemund, and Wickham 2020) package，如果想要將年/月/日格式的文字轉換為日期物件，可使用ymd()函數（y表年year，m表月month，d表日day），如果想要將月/日/年格式的文字轉換為日期物件，則使用mdy()函數，以此類推。 library(lubridate) ymd(&#39;2012/3/3&#39;) ## [1] &quot;2012-03-03&quot; mdy(&#39;3/3/2012&#39;) ## [1] &quot;2012-03-03&quot; 其他使用方式可參考 The Yhat Blog。 1.6 基本運算子 1.6.1 數學基本運算 在R中，數學運算與其他程式語言相同 加 + 減 - 乘 * 除 / 餘數 %% 次方 ^ num1&lt;-1 num2&lt;-100 num1+num2 ## [1] 101 num1-num2 ## [1] -99 num1*num2 ## [1] 100 num1/num2 ## [1] 0.01 100%%3 ##100除以3後所得餘數 ## [1] 1 2^3 ##2的3次方 ## [1] 8 ###進階數學函數 - 四捨五入 round() - 無條件捨去 floor() - 無條件進位 ceiling() num1&lt;-1.568 num2&lt;-2.121 round(num2,digits = 1) #2.121四捨五入至小數點第一位 ## [1] 2.1 floor(num1) ##1.568 ## [1] 1 ceiling(num2) ##2.121 ## [1] 3 1.6.2 邏輯運算 常用之邏輯判斷也可在R中直接使用 大於 &gt; 小於 &lt; 等於 ==，為了不與變數設定混淆，判斷兩變數是否相等，要用雙等號 大於等於 &gt;= 小於等於 &lt;= num1&lt;-1 num2&lt;-100 num1&gt;num2 ## [1] FALSE num1&lt;num2 ## [1] TRUE 文字字串也可比較大小 char1&lt;-&quot;abcTest&quot; char2&lt;-&quot;defTest&quot; char1&gt;char2 ## [1] FALSE 邏輯混合判斷，和JAVA等語言不同的是，在R中使用單符號即可表示且&amp;和或| 且 &amp; 或 | TRUE &amp; TRUE ## [1] TRUE TRUE &amp; FALSE ## [1] FALSE TRUE | TRUE ## [1] TRUE TRUE | FALSE ## [1] TRUE 反向布林變數! !TRUE ## [1] FALSE !FALSE ## [1] TRUE 1.7 錯誤訊息 Message：有可能的錯誤通知，程式會繼續執行 Warning：有錯誤，但是不會影響太多，程式會繼續執行 Error：有錯，而且無法繼續執行程式 Condition：可能會發生的情況 log(-1) ## Warning in log(-1): 產生了 NaNs ## [1] NaN mena(NA) ## Error in mena(NA): 沒有這個函數 &quot;mena&quot; 錯誤訊息範例1: # Error: could not find function &quot;fetch_NBAPlayerStatistics&quot; # 找不到&quot;fetch_NBAPlayerStatistics&quot; function 可能原因：沒安裝或沒讀入SportsAnalytics package 錯誤訊息範例2: # Error in library(knitr): there is no package called &#39;knitr&#39; # 找不到&quot;knitr&quot; package 可能原因：沒安裝knitr package 1.8 Help R語言與套件均有完整的文件與範例可以參考，在R的執行視窗中，輸入?函數名稱或?套件名稱即可看到函數或套件的使用說明 ?ggplot2 ?ymd 除此之外，Stack Overflow中也有許多問答，可直接在網站中搜尋關鍵字與錯誤訊息。 如果找不到解答，發問時請附上可以重現錯誤的程式碼與資料，以及系統/套件的版本資訊，版本資訊可以透過執行下列程式碼取得： sessionInfo() ## R version 4.0.1 (2020-06-06) ## Platform: x86_64-w64-mingw32/x64 (64-bit) ## Running under: Windows 10 x64 (build 18363) ## ## Matrix products: default ## ## locale: ## [1] LC_COLLATE=Chinese (Traditional)_Taiwan.950 ## [2] LC_CTYPE=Chinese (Traditional)_Taiwan.950 ## [3] LC_MONETARY=Chinese (Traditional)_Taiwan.950 ## [4] LC_NUMERIC=C ## [5] LC_TIME=Chinese (Traditional)_Taiwan.950 ## ## attached base packages: ## [1] grid stats graphics grDevices utils datasets methods ## [8] base ## ## other attached packages: ## [1] tidyr_1.1.0 curl_4.3 treemap_2.4-2 ## [4] purrr_0.3.4 caret_6.0-86 lattice_0.20-41 ## [7] MASS_7.3-51.6 arulesViz_1.3-3 arules_1.6-6 ## [10] Matrix_1.2-18 fields_10.3 maps_3.3.0 ## [13] spam_2.5-1 dotCall64_1.0-0 rpart.plot_3.0.8 ## [16] rpart_4.1-15 googleVis_0.6.6 ggvis_0.4.5 ## [19] plotly_4.9.2.1 shiny_1.4.0.2 treemapify_2.5.3 ## [22] WDI_2.7.1 choroplethrMaps_1.0.1 choroplethr_3.6.3 ## [25] acs_2.1.4 ggmap_3.0.0.902 maptools_1.0-1 ## [28] rgeos_0.5-3 rgdal_1.5-12 sp_1.4-2 ## [31] rvest_0.3.5 xml2_1.3.2 Rfacebook_0.6.15 ## [34] httpuv_1.5.4 rjson_0.2.20 XML_3.99-0.3 ## [37] jsonlite_1.6.1 httr_1.4.1 readxl_1.3.1 ## [40] readr_1.3.1 SportsAnalytics_0.2 reshape2_1.4.4 ## [43] stringr_1.4.0 data.table_1.12.8 RCurl_1.98-1.2 ## [46] rmarkdown_2.3 knitr_1.28 bookdown_0.20 ## [49] bit64_0.9-7.1 bit_1.1-15.2 lubridate_1.7.9 ## [52] dplyr_1.0.0 ggplot2_3.3.1 ## ## loaded via a namespace (and not attached): ## [1] uuid_0.1-4 backports_1.1.7 Hmisc_4.4-0 ## [4] igraph_1.2.5 plyr_1.8.6 lazyeval_0.2.2 ## [7] splines_4.0.1 gridBase_0.4-7 digest_0.6.25 ## [10] foreach_1.5.0 htmltools_0.4.0 viridis_0.5.1 ## [13] gdata_2.18.0 magrittr_1.5 checkmate_2.0.0 ## [16] cluster_2.1.0 gclus_1.3.2 recipes_0.1.12 ## [19] ggfittext_0.9.0 gower_0.2.1 jpeg_0.1-8.1 ## [22] colorspace_1.4-1 rappdirs_0.3.1 xfun_0.14 ## [25] crayon_1.3.4 zoo_1.8-8 survival_3.1-12 ## [28] tigris_1.0 iterators_1.0.12 glue_1.4.1 ## [31] registry_0.5-1 gtable_0.3.0 ipred_0.9-9 ## [34] scales_1.1.1 DBI_1.1.0 Rcpp_1.0.4.6 ## [37] viridisLite_0.3.0 xtable_1.8-4 htmlTable_2.0.1 ## [40] units_0.6-7 foreign_0.8-80 Formula_1.2-3 ## [43] stats4_4.0.1 lava_1.6.7 prodlim_2019.11.13 ## [46] DT_0.13 vcd_1.4-7 htmlwidgets_1.5.1 ## [49] gplots_3.0.3 RColorBrewer_1.1-2 acepack_1.4.1 ## [52] ellipsis_0.3.1 pkgconfig_2.0.3 nnet_7.3-14 ## [55] RJSONIO_1.3-1.4 tidyselect_1.1.0 rlang_0.4.6 ## [58] later_1.1.0.1 visNetwork_2.0.9 munsell_0.5.0 ## [61] cellranger_1.1.0 tools_4.0.1 generics_0.0.2 ## [64] evaluate_0.14 fastmap_1.0.1 yaml_2.2.1 ## [67] ModelMetrics_1.2.2.2 caTools_1.18.0 RgoogleMaps_1.4.5.3 ## [70] dendextend_1.13.4 packrat_0.5.0 nlme_3.1-148 ## [73] mime_0.9 compiler_4.0.1 rstudioapi_0.11 ## [76] png_0.1-7 e1071_1.7-3 tibble_3.0.1 ## [79] stringi_1.4.6 highr_0.8 classInt_0.4-3 ## [82] vctrs_0.3.1 pillar_1.4.4 lifecycle_0.2.0 ## [85] lmtest_0.9-37 bitops_1.0-6 seriation_1.2-8 ## [88] R6_2.4.1 latticeExtra_0.6-29 promises_1.1.1 ## [91] TSP_1.1-10 KernSmooth_2.23-17 gridExtra_2.3 ## [94] codetools_0.2-16 gtools_3.8.2 assertthat_0.2.1 ## [97] withr_2.2.0 hms_0.5.3 timeDate_3043.102 ## [100] class_7.3-17 pROC_1.16.2 sf_0.9-5 ## [103] scatterplot3d_0.3-41 base64enc_0.1-3 References "],
["RDataStructure.html", "2 R 資料結構 2.1 向量 vector 2.2 因子 factor 2.3 列表 list 2.4 矩陣 matrix 2.5 資料框 data.frame 2.6 資料表 data.table 2.7 資料屬性查詢函數", " 2 R 資料結構 2.1 向量 vector 向量為一維資料的表現和儲存方式，用c()函數可定義向量，如： vec&lt;-c(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;,&#39;e&#39;) a~e為vec向量中的元素(element)，各元素在向量中的順序固定，a為vec向量中的第1個元素，b則為第2個元素，以此類推，若要將vec向量的第4個元素取出，可使用 vec[4] ## 第4個元素 ## [1] &quot;d&quot; 也可同時取出多個元素 vec[c(2,3)] ## 第2與第3個元素 ## [1] &quot;b&quot; &quot;c&quot; 此外，在同一向量中，所有元素之資料型態必須相同，如上述vec向量，元素均為文字型態，若放不同類別的資料進同一個向量，資料型態會被自動轉成一樣的，範例如下 a&lt;-c(TRUE, &quot;a&quot;,1) str(a) ## chr [1:3] &quot;TRUE&quot; &quot;a&quot; &quot;1&quot; 和變數指定類似，向量中的元素也可以使用&lt;-重新指定 vec[3] ## [1] &quot;c&quot; vec[3]&lt;-&#39;z&#39; ##第三個元素值設定為“z” vec ## [1] &quot;a&quot; &quot;b&quot; &quot;z&quot; &quot;d&quot; &quot;e&quot; 2.1.1 快速產生向量函數 若要產生連續向量，如1~20，可使用:來串連首字與最後一字 1:20 ## c(1,2,...,19,20) ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 或是使用seq()函數 seq(from=1,to=20,by=1) ##1~20，中間相隔1 ## [1] 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 seq(from=1,to=50,by=2) ##1~50，中間相隔2 ## [1] 1 3 5 7 9 11 13 15 17 19 21 23 25 27 29 31 33 35 37 39 41 43 45 47 49 2.1.2 向量運算 向量也可直接做加減乘除運算，如 numvec&lt;-1:10 ## c(1,2,3,4,5,6,7,8,9,10) numvec+3 ## 所有元素+3 ## [1] 4 5 6 7 8 9 10 11 12 13 numvec*2 ## 所有元素*2 ## [1] 2 4 6 8 10 12 14 16 18 20 向量和向量也可做運算，如 numvec1&lt;-1:3 ## c(1,2,3) numvec2&lt;-4:6 ## c(4,5,6) numvec1+numvec2 ## [1] 5 7 9 numvec1*numvec2 ## [1] 4 10 18 2.2 因子 factor 因子是由向量轉換而成，多用於表示類別數據，如大學中有大學生、碩士班學生與博士班學生三種類別的學生，使用方法為factor(資料向量,levels=類別次序)，levels參數可設定各類別的次序 factor(c(&quot;大學生&quot;,&quot;碩士班學生&quot;,&quot;博士班學生&quot;), levels = c(&quot;大學生&quot;,&quot;碩士班學生&quot;,&quot;博士班學生&quot;)) ## [1] 大學生 碩士班學生 博士班學生 ## Levels: 大學生 碩士班學生 博士班學生 因子變量一但決定其類別的種類與數目時，通常不會再作更動，也就是任何新增的元素都要是大學生、碩士班學生與博士班學生其中一種。 2.3 列表 list 由於向量和因子都只能儲存一種元素，使用上彈性較不足，在R語言中，有一彈性很大的資料型態列表list，在列表中，元素可分屬不同資料類別，除了可包括數值與文字外，也可以包括資料集，如向量和因子等，更進階的使用，還可以包括矩陣與資料框。如要建立列表，可使用list()函數 listSample&lt;-list(Students=c(&quot;Tom&quot;,&quot;Kobe&quot;,&quot;Emma&quot;,&quot;Amy&quot;),Year=2017, Score=c(60,50,80,40),School=&quot;CGU&quot;) listSample ## $Students ## [1] &quot;Tom&quot; &quot;Kobe&quot; &quot;Emma&quot; &quot;Amy&quot; ## ## $Year ## [1] 2017 ## ## $Score ## [1] 60 50 80 40 ## ## $School ## [1] &quot;CGU&quot; 2.3.1 列表資料擷取 列表可用$符號做資料擷取 listSample$Students ##取得中表中的Students變量 ## [1] &quot;Tom&quot; &quot;Kobe&quot; &quot;Emma&quot; &quot;Amy&quot; 也可和向量一樣，使用索引值來擷取資料，和向量不同的是，若要取得值，要使用雙中括號[[ ]] listSample[[1]] ##取得中表中第一個變量的值 ## [1] &quot;Tom&quot; &quot;Kobe&quot; &quot;Emma&quot; &quot;Amy&quot; 如果只使用單中括號，回傳的資料型態會是列表list，並非列表中的值 listSample[1] ##取得中表中第一個變量（列表型態） ## $Students ## [1] &quot;Tom&quot; &quot;Kobe&quot; &quot;Emma&quot; &quot;Amy&quot; 2.3.2 列表資料編輯設定 列表資料也可和向量資料一樣，重新編輯設定 listSample[[1]] ## [1] &quot;Tom&quot; &quot;Kobe&quot; &quot;Emma&quot; &quot;Amy&quot; listSample[[1]]&lt;-c(&quot;小明&quot;,&quot;大雄&quot;,&quot;胖虎&quot;,&quot;小新&quot;,&quot;大白&quot;) ##將Students變量重新設定 listSample[[1]] ## [1] &quot;小明&quot; &quot;大雄&quot; &quot;胖虎&quot; &quot;小新&quot; &quot;大白&quot; 除了編輯以外，列表資料也能用$符號與&lt;-變數設定符號新增 listSample$Gender&lt;-c(&quot;M&quot;,&quot;F&quot;,&quot;M&quot;,&quot;F&quot;,&quot;M&quot;) ##新增Gender變量，並設定向量值 若需刪除某變量，可將變量值設定為NULL listSample$Score&lt;-NULL ##刪除Score變量 listSample ## $Students ## [1] &quot;小明&quot; &quot;大雄&quot; &quot;胖虎&quot; &quot;小新&quot; &quot;大白&quot; ## ## $Year ## [1] 2017 ## ## $School ## [1] &quot;CGU&quot; ## ## $Gender ## [1] &quot;M&quot; &quot;F&quot; &quot;M&quot; &quot;F&quot; &quot;M&quot; 2.4 矩陣 matrix a &lt;- matrix(c(1:6), nrow=3, ncol=2) ##建立3x2的矩陣，分別填入1~6的值 a ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 2.5 資料框 data.frame 資料框是非常常見的二維資料格式，由一系列的欄位（Column）和列（Row）所組成，常見的Excel試算表也是類似的資料表現形式，可使用data.frame()來創建新的資料框 StuDF &lt;- data.frame(StuID=c(1,2,3,4,5), ##欄位名稱=欄位值 name=c(&quot;小明&quot;,&quot;大雄&quot;,&quot;胖虎&quot;,&quot;小新&quot;,&quot;大白&quot;), score=c(80,60,90,70,50)) StuDF ## StuID name score ## 1 1 小明 80 ## 2 2 大雄 60 ## 3 3 胖虎 90 ## 4 4 小新 70 ## 5 5 大白 50 如範例所示，每個欄位都有名稱（StuID, name, score），若沒有設定欄位名稱，R會自動指派 V1 - Vn 作為欄位名稱。在R中，每個欄位的資料型態必須相同，如StuID和score為數值型態，name為文字型態。每一列也有預設的列名，R自動依序指派 1 - n 作為列名。 如需檢查欄位名稱與列名，可使用colnames()和rownames() colnames(StuDF) ##欄位名稱 ## [1] &quot;StuID&quot; &quot;name&quot; &quot;score&quot; rownames(StuDF) ##列名 ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; 如需檢查個欄位之資料型別，可使用str()函數 str(StuDF) ## &#39;data.frame&#39;: 5 obs. of 3 variables: ## $ StuID: num 1 2 3 4 5 ## $ name : chr &quot;小明&quot; &quot;大雄&quot; &quot;胖虎&quot; &quot;小新&quot; ... ## $ score: num 80 60 90 70 50 資料框可用$符號做欄位資料擷取 iris$Species ##取得iris資料框中的Species欄位 ## [1] setosa setosa setosa setosa setosa setosa ## [7] setosa setosa setosa setosa setosa setosa ## [13] setosa setosa setosa setosa setosa setosa ## [19] setosa setosa setosa setosa setosa setosa ## [25] setosa setosa setosa setosa setosa setosa ## [31] setosa setosa setosa setosa setosa setosa ## [37] setosa setosa setosa setosa setosa setosa ## [43] setosa setosa setosa setosa setosa setosa ## [49] setosa setosa versicolor versicolor versicolor versicolor ## [55] versicolor versicolor versicolor versicolor versicolor versicolor ## [61] versicolor versicolor versicolor versicolor versicolor versicolor ## [67] versicolor versicolor versicolor versicolor versicolor versicolor ## [73] versicolor versicolor versicolor versicolor versicolor versicolor ## [79] versicolor versicolor versicolor versicolor versicolor versicolor ## [85] versicolor versicolor versicolor versicolor versicolor versicolor ## [91] versicolor versicolor versicolor versicolor versicolor versicolor ## [97] versicolor versicolor versicolor versicolor virginica virginica ## [103] virginica virginica virginica virginica virginica virginica ## [109] virginica virginica virginica virginica virginica virginica ## [115] virginica virginica virginica virginica virginica virginica ## [121] virginica virginica virginica virginica virginica virginica ## [127] virginica virginica virginica virginica virginica virginica ## [133] virginica virginica virginica virginica virginica virginica ## [139] virginica virginica virginica virginica virginica virginica ## [145] virginica virginica virginica virginica virginica virginica ## Levels: setosa versicolor virginica 資料框可用$符號做欄位資料擷取後，當成向量，並使用[ ]做資料編輯。 iris$Species[2]&lt;-&quot;versicolor&quot; head(iris$Species) ## [1] setosa versicolor setosa setosa setosa setosa ## Levels: setosa versicolor virginica 若需刪除某欄位，可將欄位值設定為NULL iris$Species&lt;-NULL ##刪除Species欄位 head(iris) ## Sepal.Length Sepal.Width Petal.Length Petal.Width ## 1 5.1 3.5 1.4 0.2 ## 2 4.9 3.0 1.4 0.2 ## 3 4.7 3.2 1.3 0.2 ## 4 4.6 3.1 1.5 0.2 ## 5 5.0 3.6 1.4 0.2 ## 6 5.4 3.9 1.7 0.4 2.6 資料表 data.table data.table是data.frame資料框型別的延伸，如要使用必須安裝data.table (Dowle and Srinivasan 2019) package，使用data.table讀取大型資料的速度比使用資料框快上數倍，進階處理語言也相當好用，在探索式資料分析章節Chapter 7會詳細介紹。其他詳細教學可見 Chapter 7.2 ，DataCamp也提供互動式教學課程，可自行參閱。 2.7 資料屬性查詢函數 資料屬性可透過下列函數查詢: 名稱 names() 各維度名稱 dimnames() 長度 length() 各維度長度 dim() 資料型態 class() 各類資料計數 table() 總覽資料 str() 透過names()函數，可取得各種資料之名稱 head(islands) ##R內建的資料 ## Africa Antarctica Asia Australia Axel Heiberg Baffin ## 11506 5500 16988 2968 16 184 head(names(islands)) ##顯示上述資料之資料名稱 ## [1] &quot;Africa&quot; &quot;Antarctica&quot; &quot;Asia&quot; &quot;Australia&quot; &quot;Axel Heiberg&quot; ## [6] &quot;Baffin&quot; 若為資料框，則會顯示行（欄位）名稱 head(USArrests) ##R內建的資料 ## Murder Assault UrbanPop Rape ## Alabama 13.2 236 58 21 ## Alaska 10.0 263 48 44 ## Arizona 8.1 294 80 31 ## Arkansas 8.8 190 50 20 ## California 9.0 276 91 41 ## Colorado 7.9 204 78 39 head(names(USArrests)) ##顯示上述資料之資料名稱 ## [1] &quot;Murder&quot; &quot;Assault&quot; &quot;UrbanPop&quot; &quot;Rape&quot; 透過dimnames()函數可顯示資料框列與行的名稱，先顯示列，再顯示行 dimnames(USArrests) ## [[1]] ## [1] &quot;Alabama&quot; &quot;Alaska&quot; &quot;Arizona&quot; &quot;Arkansas&quot; ## [5] &quot;California&quot; &quot;Colorado&quot; &quot;Connecticut&quot; &quot;Delaware&quot; ## [9] &quot;Florida&quot; &quot;Georgia&quot; &quot;Hawaii&quot; &quot;Idaho&quot; ## [13] &quot;Illinois&quot; &quot;Indiana&quot; &quot;Iowa&quot; &quot;Kansas&quot; ## [17] &quot;Kentucky&quot; &quot;Louisiana&quot; &quot;Maine&quot; &quot;Maryland&quot; ## [21] &quot;Massachusetts&quot; &quot;Michigan&quot; &quot;Minnesota&quot; &quot;Mississippi&quot; ## [25] &quot;Missouri&quot; &quot;Montana&quot; &quot;Nebraska&quot; &quot;Nevada&quot; ## [29] &quot;New Hampshire&quot; &quot;New Jersey&quot; &quot;New Mexico&quot; &quot;New York&quot; ## [33] &quot;North Carolina&quot; &quot;North Dakota&quot; &quot;Ohio&quot; &quot;Oklahoma&quot; ## [37] &quot;Oregon&quot; &quot;Pennsylvania&quot; &quot;Rhode Island&quot; &quot;South Carolina&quot; ## [41] &quot;South Dakota&quot; &quot;Tennessee&quot; &quot;Texas&quot; &quot;Utah&quot; ## [45] &quot;Vermont&quot; &quot;Virginia&quot; &quot;Washington&quot; &quot;West Virginia&quot; ## [49] &quot;Wisconsin&quot; &quot;Wyoming&quot; ## ## [[2]] ## [1] &quot;Murder&quot; &quot;Assault&quot; &quot;UrbanPop&quot; &quot;Rape&quot; 透過length()函數可顯示資料長度，包括向量與資料框，若資料行態為資料框，則會顯示行（欄位）數 length(islands) ## [1] 48 length(USArrests) ## [1] 4 透過dim()函數可顯示資料框列與行的長度，與dimnames()相同，先顯示列，後顯示行 dim(USArrests) ## [1] 50 4 使用class()函數可知道變數類別 class(1) ## [1] &quot;numeric&quot; class(&quot;Test&quot;) ## [1] &quot;character&quot; class(Sys.Date()) ## [1] &quot;Date&quot; 使用table()函數可知道向量中每個值出現幾次 iris$Species ##原始值 ## NULL table(iris$Species) ##統計結果 ## &lt; table of extent 0 &gt; 使用str()函數可總覽變數資訊 str(iris) ## &#39;data.frame&#39;: 150 obs. of 4 variables: ## $ Sepal.Length: num 5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ... ## $ Sepal.Width : num 3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ... ## $ Petal.Length: num 1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ... ## $ Petal.Width : num 0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ... str(listSample) ## List of 4 ## $ Students: chr [1:5] &quot;小明&quot; &quot;大雄&quot; &quot;胖虎&quot; &quot;小新&quot; ... ## $ Year : num 2017 ## $ School : chr &quot;CGU&quot; ## $ Gender : chr [1:5] &quot;M&quot; &quot;F&quot; &quot;M&quot; &quot;F&quot; ... References "],
["controlstructure.html", "3 控制流程 3.1 條件判斷", " 3 控制流程 3.1 條件判斷 3.1.1 if-else敘述 if-else敘述使用在邏輯判斷，若需要依條件改變需要執行的程式碼，就會使用if-else，若if後所接邏輯判斷為真(TRUE)，就會執行if下方之程式碼，若為偽(FALSE)，則執行else下方之程式碼，若程式中沒有else片段，則不執行任何程式碼。 if與else下方的程式碼必須要使用{}將程式碼包起來，若程式碼只有一行，可省略{}，但為閱讀方便，建議不要省略{}。 舉例來說，若考試分數大於等於60分，則印出及格字樣，小於60分則印出不及格字樣，程式範例如下: score&lt;-59 if(score&gt;=60){ print(&quot;及格&quot;) }else{ print(&quot;不及格&quot;) } ## [1] &quot;不及格&quot; score&lt;-80 if(score&gt;=60){ print(&quot;及格&quot;) }else{ print(&quot;不及格&quot;) } ## [1] &quot;及格&quot; 3.1.2 if-else if-else 很多時候必須要使用多重邏輯判斷，若考試分數大於等於90分，印出優良，介於60到90分間，印出及格，小於60分則印出不及格，此時就會用到多重邏輯，使用多重邏輯時，會在if和else間新增邏輯區段else if，程式範例如下: score&lt;-95 if(score&gt;=90){ print(&quot;優秀&quot;) }else if(score&gt;=60){ print(&quot;及格&quot;) }else{ print(&quot;不及格&quot;) } ## [1] &quot;優秀&quot; if-else if-else敘述是有順序的，若在if敘述判斷為真，就算後方else if判斷也為真，也只會執行if區段的程式碼，如上述範例，95分大於等於90分(if邏輯)，也大於等於60分(else if邏輯)，但最後只印出優秀字樣。 ###巢狀if 巢狀if是指在if區段程式碼內包含其他if-else判斷，舉例來說，若國文分數與英文分數皆大於等於60分，印出全部及格，國文分數大於等於60分，英文小於60分，則印國文及格，英文再加油，以此類推，程式範例如下: CHscore&lt;-95 ##國文成績 ENscore&lt;-55 ##英文成績 if(CHscore&gt;=60){ if(ENscore&gt;=60){ print(&quot;全部及格&quot;) }else{ print(&quot;國文及格，英文再加油&quot;) } }else{ if(ENscore&gt;=60){ print(&quot;英文及格，國文再加油&quot;) }else{ print(&quot;全部不及格&quot;) } } ## [1] &quot;國文及格，英文再加油&quot; ###ifelse() ifelse()函數可用最短的方式取代if-else敘述，使用方法為ifelse(邏輯判斷,判斷為真要執行的程式碼,判斷為偽要執行的程式碼)，依上述範例，重寫程式碼如下: score&lt;-80 ifelse(score&gt;=60,&quot;及格&quot;,&quot;不及格&quot;) ## [1] &quot;及格&quot; 值得注意的是，ifelse()可判斷向量，也就是可一次判斷多個元素 scoreVector&lt;-c(30,90,50,60,80) ifelse(scoreVector&gt;=60,&quot;及格&quot;, &quot;不及格&quot;) ## [1] &quot;不及格&quot; &quot;及格&quot; &quot;不及格&quot; &quot;及格&quot; &quot;及格&quot; ##迴圈 ###for R語言的for迴圈寫法和其他語言不同，首先必須建立需要逐一執行的參數向量或序列，再使用for迴圈逐一執行，程式寫法為for (單一變數 in 參數向量){ 程式碼 }，範例如下: for (n in 1:10){ #n為單一變數，1:10為需要逐一執行的參數向量 print(n) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 for迴圈也可和if-else函數合併使用，如: for (n in 1:10){ if(n%%2==0){ #偶數直接輸出數字 print(n) }else{ print(&quot;奇數&quot;) #奇數則輸出&quot;奇數&quot; } } ## [1] &quot;奇數&quot; ## [1] 2 ## [1] &quot;奇數&quot; ## [1] 4 ## [1] &quot;奇數&quot; ## [1] 6 ## [1] &quot;奇數&quot; ## [1] 8 ## [1] &quot;奇數&quot; ## [1] 10 ###while while函數則是在每次執行迴圈時檢查while邏輯判斷是否為真，若邏輯判斷為真，就會執行區段程式碼，若邏輯判斷為偽，則會結束迴圈執行。 x&lt;-0 while(x&lt;=5){ print(x) x&lt;-x+1 } ## [1] 0 ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 5 ###break 若遇特殊情形想結束迴圈執行，可使用break指令 for(n in 1:10){ if(n==5){ break ##一執行到5，跳出迴圈，不再執行之後的迴圈 } print(n) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ###next 若遇特殊情形想跳過迴圈執行，可使用next指令 for(n in 1:10){ if(n==5){ next ##跳過5，直接執行下一個迴圈 } print(n) } ## [1] 1 ## [1] 2 ## [1] 3 ## [1] 4 ## [1] 6 ## [1] 7 ## [1] 8 ## [1] 9 ## [1] 10 ##purrr better than sapply() and lapply() "],
["function.html", "4 函數 4.1 為什麼需要函數 4.2 函數組成 4.3 函數命名原則 4.4 函數範例 4.5 函式編程Functional programming 4.6 purrr 4.7 map2 family 4.8 參考資料", " 4 函數 4.1 為什麼需要函數 在R for Data Science中提到，要變成傑出的資料科學家，學習如何撰寫函數（function）是非常好的方法，函數的優點包括： 使程式碼更好理解 若需修改程式碼，若有搭配function的使用，只需要修改函數中的程式碼，其他部分則維持原有叫用函數方式即可 程式碼可以重複使用 也因此，如果同一段程式碼已經被剪下貼上兩次，那就是寫一個函式(Function)的時機。 舉例來說，若我們要計算iris資料中Sepal.Length和Sepal.Width的比例，以及Petal.Length和Petal.Width的比例，並且四捨五入到小數點第一位，沒有使用函數的程式碼如下： round(iris$Sepal.Length/iris$Sepal.Width,1)[1:5] ## [1] 1.5 1.6 1.5 1.5 1.4 round(iris$Petal.Length/iris$Petal.Width,1)[1:5] ## [1] 7.0 7.0 6.5 7.5 7.0 每次計算都需指定 ,1 ，以完成四捨五入到小數點第一位的任務。 4.2 函數組成 要學習如何撰寫函數，首先須了解函數包含四個重要的部分: 名字 Function Name function_name 參數 Arguments, optional arg_1, arg_2, ... 程式碼本體 Function Body 回傳值 Return Value, optional return_value 名字&lt;-function(參數1,參數2,...){ 程式碼本體 最後一行的輸出自動設為回傳值 } 而撰寫函數有四個重要步驟: 先寫出可以用的程式碼 將程式碼內可以重複使用的部分指派給臨時變數 其餘程式碼用臨時變數表示，讓程式碼變簡潔 把程式碼變成函數function 以常見的函數mean()為例，其實就是將輸入向量加總後，除以個數，完成平均值的計算 mean(1:6) ## [1] 3.5 (1+2+3+4+5+6)/6 ## [1] 3.5 sum(1:6)/length(1:6) ## [1] 3.5 也因此，若我們想要自己撰寫一個計算平均值的函數myMean()，只要將上述邏輯寫入function內即可 myMean&lt;-function(vec){ m&lt;-sum(vec)/length(vec) return(m) } myMean(1:6) ## [1] 3.5 myMean(2:10) ## [1] 6 又以計算三次方為例，其實就是將輸入數字x自乘三次，程式碼如下： cube&lt;-function(x){ x_cube&lt;-x*x*x return(x_cube) } cube(2) ## [1] 8 cube(4) ## [1] 64 cube(6) ## [1] 216 4.3 函數命名原則 根據上述兩個簡單的函數，可以發現寫好的函數的方法是先確保程式的正確性，再確保函數是否容易閱讀與理解，為了達成函數的易理解性，函數有以下建議的命名原則: 長的函數名稱要遵循一樣的命名樣式 不要用原本就存在R中的函數名稱 可以被理解的名稱，通常是動詞 而參數也有對應的命名原則: 可以被理解的名稱 通常是名詞 輸入資料參數通常放在第一個 其他設定值通常會設定預設值 4.4 函數範例 接下來的範例使用兩個參數，height與weight，計算BMI值，並且考慮到輸入身高的單位可能會是公分的情況，邏輯為假設輸入的身高&gt;5，因正常人身高不可能大於5公尺，因此假設輸入之單位為公分，需要在函數內將公分換算為公尺： cal_bmi&lt;-function(height,weight){ if(height&gt;5){ height &lt;- height/100 } bmi &lt;- weight / height**2 return(bmi) } cal_bmi(160,50) ## [1] 20 cal_bmi(1.6,50) ## [1] 20 4.5 函式編程Functional programming 函式編程（Functional programming）的技巧可以用在所有支援函數為一等公民（First Class）的程式語言，其中包括： 可以將函數指定為一個變數 Assign a function to a variable 可以將函數當作參數傳遞 Pass a function as an argument 可以回傳一個函數 Return a function 其中，可以將函數指定為一個變數在前述程式碼中其實已經出現過，在cal_bmi 函數中，我們就是將cal_bmi 變數設定為cal_bmi函數： cal_bmi&lt;-function(height,weight){ if(height&gt;5){ height &lt;- height/100 } bmi &lt;- weight / height**2 return(bmi) } cal_bmi(160,50) ## [1] 20 cal_bmi(1.6,50) ## [1] 20 而將函數當作參數並且傳遞的功能，在R中是非常實用且必須要學習的功能，在purrr(Henry and Wickham 2020)套件中，此功能被大量應用。最後則是將函數回傳的功能，以下以hello()以及sayHello()函數為例，在sayHello()函數中，回傳值即為hello()函數。 hello&lt;-function(){ print(&quot;Hello&quot;) } sayHello &lt;- function() { return(hello()) } sayHello() ## [1] &quot;Hello&quot; 4.6 purrr 而上述支援函數為一等公民（First Class）的條件，最實用的應該為在purrr套件中，將函數當作參數傳遞，purrr套件提供一系列功能，將向量與函數的功能搭配，解決for迴圈速度很慢且程式碼很長的問題，在purrr套件中最重要的功能是map家族，包括map(), map_chr(), map_int(), map_dbl(), map_df(), walk()等，概念如下： 圖片來源 以下為將學生成績開根號乘以10的函數，可以發現若輸入的原始成績是30分，輸出則是加分後的成績，若原始成績是50分，輸出成績就會及格，如果只是要算兩位同學的成績，一筆一筆輸入不是什麼大問題，但若要計算30名學生的成績，要打30次程式碼，還是非常麻煩的。 good_teacher_score&lt;-function(ori_score){ better_score&lt;-sqrt(ori_score)*10 return(better_score) } good_teacher_score(30) ## [1] 55 good_teacher_score(50) ## [1] 71 以下為計算30個學生的成績時的程式碼，可以看到每筆成績都需要耗費一行程式碼來處理，十分麻煩。 ori_score_list&lt;-sample(1:100,30) ori_score_list[1:3] ## [1] 87 60 9 good_teacher_score(ori_score_list[1]) ## [1] 93 good_teacher_score(ori_score_list[2]) ## [1] 77 #..... 此時若能妥善利用purrr套件的map_dbl功能，就能將程式碼縮短，並且提升易讀性。map()函數家族的使用概念為map(需逐一計算的向量,計算所需的函數)，如下所示，我們需要計算的學生原始成績存在ori_score_list向量中，而加分的函數為good_teacher_score()： 圖片來源 學生原始成績存在ori_score_list變數內： ori_score_list ## [1] 87 60 9 5 84 77 64 54 81 70 95 58 59 7 66 20 28 25 94 3 35 78 12 24 39 ## [26] 53 98 4 16 10 使用map_dbl將每位學生的成績加分： library(purrr) new_score_list&lt;- map_dbl(ori_score_list, good_teacher_score) data.frame(ori_score_list, new_score_list) ori_score_list new_score_list 87 93 60 77 9 30 5 22 84 92 77 88 64 80 54 73 81 90 70 84 95 97 58 76 59 77 7 26 66 81 20 45 28 53 25 50 94 97 3 17 35 59 78 88 12 35 24 49 39 62 53 73 98 99 4 20 16 40 10 32 使用map函數即可完成逐一計算向量中原始成績的任務。 4.7 map2 family map函數的設計是輸入一組需逐一計算的向量，但有時我們需要兩組成對且需逐一計算的向量，這時就可以使用map2家族函數，概念為輸入兩組成對且需逐一計算的向量，成對帶入後置函數內，完成計算。 圖片來源 以計算加權成績為例，我們有一組學生的國文成績chi_score以及英文成績eng_score，並且希望將這些成績以（國文成績+2*英文成績）的方式做加權計算，首先，我們須先將加權的程式碼撰寫成weight_score()函數，並使用map2家族函數，完成逐一計算的任務。map2家族函數的使用方法為map2_dbl(需逐一計算的向量1,需逐一計算的向量2,計算所需的函數)。 首先建立國文成績chi_score以及英文成績eng_score向量： chi_score&lt;-c(60,50,40) eng_score&lt;-c(60,50,40) 完成向量值的指定後，撰寫（國文成績+2*英文成績）加權計算函數weight_score()： weight_score&lt;-function(chi,eng){ final_score&lt;-chi+eng*2 return(final_score) } 使用map2家族函數，完成逐一計算的任務： weight_score_list&lt;- map2_dbl(chi_score, eng_score, weight_score) data.frame(chi_score, eng_score, weight_score_list) chi_score eng_score weight_score_list 60 60 180 50 50 150 40 40 120 4.8 參考資料 R for Data Science Advanced R purrr package References "],
["io.html", "5 資料讀取與匯出 5.1 Facebook資料擷取 5.2 資料匯出", " 5 資料讀取與匯出 資料(Data)在維基百科的定義是values of qualitative or quantitative variables, belonging to a set of items.，一般來說，在資料分析前會經過多個步驟，包括資料匯入Chapter 5、資料清洗處理Chapter 6並轉換為Tidy data、資料分析Chapter 7、資料呈現與視覺化Chapter 8。 資料有多種可能來源，包括: 硬碟 網路下載 Open Data (API) 網頁裡 (爬蟲！) 任何地方 以下介紹由檔案、網路等來源匯入多種資料格式的匯入方式，以及建議的資料匯出方法。 ##從檔案匯入基本資料格式 {#file} ###Import Dataset功能 (RStudio) RStudio 1.0版後即提供很好的資料匯入介面，使用者可以不用撰寫任何程式碼，就能完成.csv、Excel以及SAS等檔案匯入。首先選取RStudio四分割視窗右上角的Environment標籤，選擇Import Dataset，就會出現檔案格式的選項 以csv檔案為例，在選單中選取From CSV，選取後會跳出資料匯入輔助視窗，點選Browse按鈕開啟檔案選取器，並點選欲匯入之文字檔案 檔案選取後，資料匯入輔助視窗有預覽功能，供使用者檢查資料匯入方法是否正確，若需調整各項參數，可利用下方Import Options的選項微調，最常用的調整功能是Delimiter分隔符號與First Row as Names首列是否為欄位名稱。 如果要匯入的檔案為tab分隔文字檔，一樣可以選擇.csv選項，再修改Delimiter參數為Tab即可。 資料匯入輔助視窗右下方Code Preview:子視窗中會自動產生資料匯入程式碼，如果未來想再使用視窗匯入，希望透過程式碼匯入，可以將此段程式碼複製貼上到R程式碼檔案(.R)，供後續分析使用。 ###分隔文字檔 .txt readr (Wickham, Hester, and Francois 2018) package提供完整的文字檔讀取功能，各讀取函數的第一個參數通常為檔案路徑與名稱，read_delim()函數可用來讀取所有用分隔符號分隔的文字檔案，以tab分隔為例，只需將delim參數設定為\\t，即可用tab將各欄位分開讀取。此外，col_names參數也常被使用，TRUE代表資料內有包含欄位名稱(通常在首列)，預設為TRUE，如果設定為FALSE，欄位名稱則會依順序被設定為 X1, X2, X3 …。 參數整理如下 (可用?read_delim指令閱讀官方說明)： file, 檔名 delim, 分隔符號 quote, 把欄位包起來的符號 escape_backslash, 預設FALSE，是否用/作為逃脫符號 escape_double, 預設TRUE，是否用quote符號作為逃脫符號 col_names, 是否有欄位名稱（表頭）（T/F） col_types, 每一個欄位的類別，用向量表示 comment, 備註標示符號，在備註標示符號之後的文字不會被讀入 skip, 要跳過幾行？ library(readr) dataset &lt;- read_delim(&quot;檔案路徑與名稱&quot;, delim=&quot;\\t&quot;) ###CSV檔案 .csv {#csv} readr (Wickham, Hester, and Francois 2018) package也提供CSV (逗號分隔)檔案的讀取功能，read_csv() library(readr) dataset &lt;- read_csv(&quot;檔案路徑與名稱&quot;) ###Excel檔案 .xls readxl (Wickham and Bryan 2019) package提供讀取Excel檔案 (xls, xlsx)的函數read_excel()，除了常用的col_names參數外，也可使用sheet參數設定要讀取的工作表(sheet) library(readxl) dataset &lt;- read_excel(&quot;檔案路徑與名稱&quot;) ###R物件 .rds R物件有檔案小與讀取快速的優點，如果在R程式處理資料後必須儲存一份以供後續分析的話，使用R物件儲存是最佳的方式，讀取R物件有多種函數可供選擇，推薦使用readRDS()函數 (參考資料:A better way of saving and loading objects in R) dataset &lt;- readRDS(&quot;檔案路徑與名稱&quot;) ###R程式 .R source, 讀R的Obejct or script, 執行, ASCII (dump的相反) 5.0.1 純文字資料 (無分隔) readLines, 逐行讀取文字資料 ###其他格式 透過載入套件，R可讀入許多其他格式的檔案: MySQL RMySQL HDF5 rhdf5 Weka foreign Stata foreign SPSS Hmisc SAS Hmisc GIS rgdal Images jpeg Music tuneR 5.0.2 其他讀檔注意事項 讀檔的時候R會自動 跳過#開頭的任何行（Row） 判斷要讀幾行 判斷每個列（Column）的類別 把欄位包起來的符號 如果讀取時已指定Column類別以及把欄位包起來的符號，讀取速度會快很多。 ##從網路匯入資料 ### Open Data 開放資料 (Open data) 指的是一種經過挑選與許可的資料，這些資料不受著作權、專利權，以及其他管理機制所限制，可以開放給社會公眾，任何人都可以自由出版使用，不論是要拿來出版或是做其他的運用都不加以限制。Open data 運動希望達成的目標與開放原始碼、內容開放、開放獲取等其他「開放」運動類似。Open data 背後的核心思想由來已，但 Open data 這名詞直到近代才出現，拜網際網路崛起而為人所知，尤其是 Data.gov 等 Open data 政府組織的設立。(維基百科) 台灣政府從2011年開始大力推動開放政府與開放資料的概念，多個機關與縣市政府架設開放資料平台，供民眾擷取或再利用各項資料 政府資料開放平台 Data Taipei 開放資料 x 開放桃園 內政資料開放平台 Open Data常見的儲存方式為: CSVChapter ??、JSONChapter ??、XMLChapter 5.0.4，開放資料網站通常有提供民眾直接下載檔案的服務，針對可下載的CSV格式資料，可以下載完成後，透過上述由檔案匯入資料 Chapter ??方法匯入即可。 5.0.3 API (Application programming interfaces) 應用程式介面 Application programming interfaces (API) 通常是特定軟體、程序或系統，廠商或開發人員，為了能夠讓第三方的開發者可以額外開發應用程式來強化他們的產品，所推出可以與他們系統溝通的介面。(維基百科) 以下載Open Data為例，若檔案更新頻繁，使用手動下載相當耗時。如臺北市開放認養動物資料，更新頻率為每日，所以許多開放資料也提供透過API下載的服務，透過API下載的資料格式會是JSON格式Chapter ??，如臺北市開放認養動物API資訊所示，開放資料網站會提供資料集ID與資料RID 資料集ID: 紀錄資料的基本參數，如包含欄位、更新頻率等 資料RID: 資料集 並同時提供擷取範例，如果需要下載原始資料，可直接從範例複製貼上即可，如http://data.taipei/opendata/datalist/apiAccess?scope=resourceAquire&amp;rid=f4a75ba9-7721-4363-884d-c3820b0b917c ###JSON格式檔案 {#json} JSON (Javascript Object Notation)是一種輕量級的資料交換語言 (Wiki)，特色如下: from application programming interfaces (APIs) JavaScript、Java、Node.js應用 一些NoSQL非關連型資料庫用JSON儲存資料：MongoDB 資料儲存格式 Numbers (double) Strings (double quoted) Boolean (true or false) Array (ordered, comma separated enclosed in square brackets []) Object (unorderd, comma separated collection of key:value pairs in curley brackets {}) JSON檔案範例 許多Open Data也用JSON格式儲存，例如臺北市開放認養動物資料，根據資料的API資訊，可得資料擷取網址http://data.taipei/opendata/datalist/apiAccess?scope=resourceAquire&amp;rid=f4a75ba9-7721-4363-884d-c3820b0b917c 。 將JSON檔案匯入R可以使用jsonlite(Ooms 2020) package，套件使用前必須安裝，安裝套件方法請參考Chapter 1，載入後，可使用fromJSON()函數載入JSON資料。 如API網址為httr類別，需要載入httr(???) package，並使用GET()函數處理資料擷取網址。 PetData&lt;-jsonlite::fromJSON(&quot;http://data.taipei/opendata/datalist/apiAccess?scope=resourceAquire&amp;rid=f4a75ba9-7721-4363-884d-c3820b0b917c&quot;) str(PetData) ## List of 1 ## $ result:List of 5 ## ..$ limit : int 1000 ## ..$ offset : int 0 ## ..$ count : int 365 ## ..$ sort : chr &quot;&quot; ## ..$ results:&#39;data.frame&#39;: 365 obs. of 20 variables: ## .. ..$ AcceptNum : chr [1:365] &quot;106060601&quot; &quot;106060401&quot; &quot;106060210&quot; &quot;106060207&quot; ... ## .. ..$ IsSterilization: chr [1:365] &quot;未絕育&quot; &quot;已絕育&quot; &quot;未絕育&quot; &quot;未絕育&quot; ... ## .. ..$ Name : chr [1:365] &quot;&quot; &quot;&quot; &quot;俊俊&quot; &quot;小莊&quot; ... ## .. ..$ Variety : chr [1:365] &quot;米克斯&quot; &quot;米克斯&quot; &quot;米克斯&quot; &quot;米克斯&quot; ... ## .. ..$ Age : chr [1:365] &quot;成年&quot; &quot;成年&quot; &quot;成年&quot; &quot;成年&quot; ... ## .. ..$ ChildreAnlong : chr [1:365] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## .. ..$ Resettlement : chr [1:365] &quot;臺北市動物之家 收容編號106060601&quot; &quot;&quot; &quot;臺北市動物之家 收容編號106060210&quot; &quot;臺北市動物之家 收容編號106060207&quot; ... ## .. ..$ Sex : chr [1:365] &quot;雄&quot; &quot;雌&quot; &quot;雄&quot; &quot;雄&quot; ... ## .. ..$ Note : chr [1:365] &quot;左剪耳 輕微脫水 精神食慾不佳&quot; &quot;&quot; &quot;嗨~~我的名字叫俊俊，希望帥氣的我可以受您的青睞，快來動物之家看看我吧!\\n&quot; &quot;哈囉~我的名字叫小莊，目前我在動物之家生活，希望能快快找到，願意認養我的人來帶我回家!!\\n&quot; ... ## .. ..$ Phone : chr [1:365] &quot;02-87913063&quot; &quot;&quot; &quot;02-87913062&quot; &quot;02-87913062&quot; ... ## .. ..$ Reason : chr [1:365] &quot;民眾不擬續養&quot; &quot;民眾不擬續養&quot; &quot;動物管制&quot; &quot;動物管制&quot; ... ## .. ..$ ImageName : chr [1:365] &quot;http://163.29.39.183/uploads/images/medium/c0f66294-143c-4406-8714-2e6764352b13.jpg&quot; &quot;http://163.29.39.183/uploads/images/medium/4ffa231f-3108-43c1-8ccf-b8578bdf1e1a.jpg&quot; &quot;http://163.29.39.183/uploads/images/medium/e68771df-747e-4544-846a-bdd6099e7f90.jpg&quot; &quot;http://163.29.39.183/uploads/images/medium/fd75d049-5310-4016-b1f4-71d69c4a9912.jpg&quot; ... ## .. ..$ HairType : chr [1:365] &quot;虎斑白&quot; &quot;黃白&quot; &quot;黃白&quot; &quot;黃&quot; ... ## .. ..$ Build : chr [1:365] &quot;中&quot; &quot;中&quot; &quot;中&quot; &quot;中&quot; ... ## .. ..$ AnimalAnlong : chr [1:365] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... ## .. ..$ ChipNum : chr [1:365] &quot;900073000086900&quot; &quot;900073000086481&quot; &quot;&quot; &quot;&quot; ... ## .. ..$ _id : int [1:365] 1 2 3 4 5 6 7 8 9 10 ... ## .. ..$ Type : chr [1:365] &quot;貓&quot; &quot;貓&quot; &quot;貓&quot; &quot;貓&quot; ... ## .. ..$ Email : chr [1:365] &quot;tcapoa8@mail.taipei.gov.tw&quot; &quot;&quot; &quot;tcapoa8@mail.taipei.gov.tw&quot; &quot;tcapoa8@mail.taipei.gov.tw&quot; ... ## .. ..$ Bodyweight : chr [1:365] &quot;&quot; &quot;&quot; &quot;&quot; &quot;&quot; ... 由資料結構可知，經過fromJSON()函數匯入的JSON檔案被轉存為列表list的型態，且在result元素中包含五個子元素(offset, limit, count, sort, results)，其中，results子元素的類別為資料框data.frame，內含開放認養動物清單，因此，可使用$符號截取元素與子元素 head(PetData$result$results) ## AcceptNum IsSterilization Name Variety Age ChildreAnlong ## 1 106060601 未絕育 米克斯 成年 ## 2 106060401 已絕育 米克斯 成年 ## 3 106060210 未絕育 俊俊 米克斯 成年 ## 4 106060207 未絕育 小莊 米克斯 成年 ## 5 106060203 未絕育 好橙 米克斯 成年 ## 6 106053107 未絕育 歐雅 米克斯 年輕 ## Resettlement Sex ## 1 臺北市動物之家 收容編號106060601 雄 ## 2 雌 ## 3 臺北市動物之家 收容編號106060210 雄 ## 4 臺北市動物之家 收容編號106060207 雄 ## 5 臺北市動物之家 收容編號106060203 雄 ## 6 臺北市動物之家 收容編號106053107 雌 ## Note ## 1 左剪耳 輕微脫水 精神食慾不佳 ## 2 ## 3 嗨~~我的名字叫俊俊，希望帥氣的我可以受您的青睞，快來動物之家看看我吧!\\n ## 4 哈囉~我的名字叫小莊，目前我在動物之家生活，希望能快快找到，願意認養我的人來帶我回家!!\\n ## 5 嗨~我的名字叫好橙，害羞的我想要一個溫暖的家，您可以給我這個機會嗎?\\n ## 6 大家好~我的名字叫歐雅，我的個性緊張，想帶我回家，要有耐心陪伴我渡過適應期唷! ## Phone Reason ## 1 02-87913063 民眾不擬續養 ## 2 民眾不擬續養 ## 3 02-87913062 動物管制 ## 4 02-87913062 動物管制 ## 5 02-87913062 動物管制 ## 6 02-87913062 動物管制 ## ImageName ## 1 http://163.29.39.183/uploads/images/medium/c0f66294-143c-4406-8714-2e6764352b13.jpg ## 2 http://163.29.39.183/uploads/images/medium/4ffa231f-3108-43c1-8ccf-b8578bdf1e1a.jpg ## 3 http://163.29.39.183/uploads/images/medium/e68771df-747e-4544-846a-bdd6099e7f90.jpg ## 4 http://163.29.39.183/uploads/images/medium/fd75d049-5310-4016-b1f4-71d69c4a9912.jpg ## 5 http://163.29.39.183/uploads/images/medium/2f750fef-b696-4595-8fbf-cc6adf8f72d5.jpg ## 6 http://163.29.39.183/uploads/images/medium/1c293e5e-99db-466e-a156-ff33fef368b4.jpg ## HairType Build AnimalAnlong ChipNum _id Type ## 1 虎斑白 中 900073000086900 1 貓 ## 2 黃白 中 900073000086481 2 貓 ## 3 黃白 中 3 貓 ## 4 黃 中 4 貓 ## 5 黃 中 5 貓 ## 6 黑 中 6 貓 ## Email Bodyweight ## 1 tcapoa8@mail.taipei.gov.tw ## 2 ## 3 tcapoa8@mail.taipei.gov.tw ## 4 tcapoa8@mail.taipei.gov.tw ## 5 tcapoa8@mail.taipei.gov.tw ## 6 tcapoa8@mail.taipei.gov.tw results資料框中包含20個欄位，可以像分析資料框一樣，針對此資料框做分析，舉例來說，可分析各項開放認養理由出現次數 table(PetData$result$results$Reason) ## ## 民眾不擬續養 民眾拾獲 動物救援 動物管制 ## 28 50 23 109 155 分析可知開放認養理由以動物管制與未填寫居多。 如果需要將資料框轉換成JSON檔案可以使用jsonlite package所提供的toJSON()函數。 myjson &lt;- jsonlite::toJSON(iris, pretty=TRUE) str(myjson) ## &#39;json&#39; chr &quot;[\\n {\\n \\&quot;Sepal.Length\\&quot;: 5.1,\\n \\&quot;Sepal.Width\\&quot;: 3.5,\\n \\&quot;Petal.Length\\&quot;: 1.4,\\n \\&quot;Petal.Width\\&quot;:&quot;| __truncated__ 5.0.4 XML 可延伸標記式語言 Extensible markup language 描述結構化資料的語言 處理XML檔案是網頁Html爬蟲的基礎 Components Markup 標記 - labels that give the text structure Content 內文 - the actual text of the document XML Wiki Tags, elements and attributes Tags correspond to general labels Start tags &lt;breakfast_menu&gt;, &lt;price&gt; End tags &lt;/breakfast_menu&gt;,&lt;/price&gt; Empty tags &lt;line-break /&gt; Elements are specific examples of tags &lt;name&gt;Belgian Waffles&lt;/name&gt; Attributes are components of the label &lt;book category=\"web\"&gt; 許多Open Data也用XML格式儲存，例如臺北市水質監測資訊。 5.0.4.1 XML 套件 如需將XML檔案匯入R中，需要安裝XML (Temple Lang 2020) package，使用xmlParse()函數將檔案匯入。若出現Error: 1: Unknown IO error2: failed to load external entity，是因為XML套件處理http轉https的功能的不好，載入httr套件後，先使用GET()功能取用網址，再放入xmlParse()就不會有問題。 library(XML) library(httr) waterQ &lt;- xmlParse(GET(&quot;https://data.taipei/opendata/datalist/datasetMeta/download?id=961ca397-4a59-45e8-b312-697f26b059dc&amp;rid=190796c8-7c56-42e0-8068-39242b8ec927&quot;)) 完成資料讀取後，使用xpathSApply()函數搭配XPath語法取得指定標籤內的資料，依需求也可改用xpathApply()函數，差別在於xpathSApply()函數回傳的物件是Vector 向量 ，而xpathApply()回傳的物件是List 列表。 #取得所有&quot;code_name&quot;標籤內的資料 xpathSApply(waterQ,&quot;//code_name&quot;,xmlValue)[1:10] ## [1] &quot;雙溪淨水場&quot; &quot;衛理女中&quot; ## [3] &quot;雙溪國小 &quot; &quot;華興加壓站&quot; ## [5] &quot;長興淨水場&quot; &quot;市政大樓&quot; ## [7] &quot;市議會&quot; &quot;捷運忠孝復興站&quot; ## [9] &quot;南港高工&quot; &quot;南港加壓站&quot; #取得各監測站的經度 xpathSApply(waterQ,&quot;//longitude&quot;,xmlValue)[1:10] ## [1] &quot;121.569433&quot; &quot;121.55231&quot; &quot;121.563886&quot; &quot;121.544384&quot; &quot;121.547873&quot; ## [6] &quot;121.563997&quot; &quot;121.561975&quot; &quot;121.54342&quot; &quot;121.607462&quot; &quot;121.616217&quot; 在xpathApply()與xpathSApply()函數中，第二個參數為XPath，XPath是XML路徑語言（XML Path Language），基於XML的樹狀結構，提供在資料結構樹中找尋節點的能力，XPath語法的邏輯，可參考W3C Schools或是Google搜尋相關中文教學，如lxml、XPath 常用語法。在此列舉幾個常用的語法: // 子結點資料, 如所有連結標籤 //a @ 屬性資料, 如所有連結標籤內的連結網址 //a/@href 5.0.4.2 xml2 套件 除了XML套件外，也可使用xml2(Wickham, Hester, and Ooms 2020)套件來處理XML格式的檔案，同樣使用臺北市水質監測資訊為例，首先透過read_xml()函數將XML檔案匯入： library(xml2) waterURL&lt;-&quot;http://data.taipei/opendata/datalist/datasetMeta/download?id=961ca397-4a59-45e8-b312-697f26b059dc&amp;rid=190796c8-7c56-42e0-8068-39242b8ec927&quot; waterQ &lt;- read_xml(waterURL) 完成讀取後，使用xml_find_all()以及xml_text()函數取得指定標籤內的資料： #取得所有&quot;code_name&quot;標籤內的資料 code_name_xml&lt;-xml_find_all(waterQ, &quot;.//code_name&quot;) code_name&lt;-xml_text(code_name_xml) code_name[1:10] ## [1] &quot;雙溪淨水場&quot; &quot;衛理女中&quot; ## [3] &quot;雙溪國小 &quot; &quot;華興加壓站&quot; ## [5] &quot;長興淨水場&quot; &quot;市政大樓&quot; ## [7] &quot;市議會&quot; &quot;捷運忠孝復興站&quot; ## [9] &quot;南港高工&quot; &quot;南港加壓站&quot; #取得各監測站的經度longitude longitude_xml&lt;-xml_find_all(waterQ, &quot;.//longitude&quot;) longitude&lt;-xml_text(longitude_xml) longitude[1:10] ## [1] &quot;121.569433&quot; &quot;121.55231&quot; &quot;121.563886&quot; &quot;121.544384&quot; &quot;121.547873&quot; ## [6] &quot;121.563997&quot; &quot;121.561975&quot; &quot;121.54342&quot; &quot;121.607462&quot; &quot;121.616217&quot; 以上兩種套件均可完成XML檔案的處理，可依喜好選擇幾喜歡的套件。 5.0.5 網頁爬蟲 Webscraping 由於不是每個網站都提供API，但網頁上卻有你想要分析的資料（像是ptt推文！？），除了人工複製貼上以外，也可以將網頁處理程式化，以程式化的方式擷取網頁資料就叫做網頁爬蟲（Webscraping）（Webscraping Wiki）。在R中可以直接把HTML檔案當作XML檔案處理分析，也可使用rvest(Wickham 2019a) package輔助爬蟲程式撰寫。 此外，網頁爬蟲可能耗費很多網頁流量和資源，所以在許多網站被視為非法行為，如果一次讀太多太快，很可能被鎖IP。 以長庚資管系網站為例，可直接逐行讀取 readLines() con &lt;- url(&quot;https://im.cgu.edu.tw/&quot;) htmlCode &lt;-readLines(con) ## Warning in readLines(con): 於 &#39;https://im.cgu.edu.tw/&#39; 找到不完整的最後一列 close(con) htmlCode[1:5] ## [1] &quot;&lt;!DOCTYPE html&gt;&quot; ## [2] &quot;&lt;html lang=\\&quot;zh-tw\\&quot;&gt;&quot; ## [3] &quot;&lt;head&gt;&quot; ## [4] &quot;&lt;meta http-equiv=\\&quot;Content-Type\\&quot; content=\\&quot;text/html; charset=utf-8\\&quot;&gt;&quot; ## [5] &quot;&lt;meta http-equiv=\\&quot;X-UA-Compatible\\&quot; content=\\&quot;IE=edge,chrome=1\\&quot; /&gt;&quot; 或是使用XML工具分析擷取網頁 (XML package)，使用方法與XML檔案處理方法類似，搭配XPath語言，篩選所需資料 html &lt;- htmlParse(&quot;https://im.cgu.edu.tw/&quot;) xpathSApply(html, &quot;//title&quot;, xmlValue) ## list() xpathSApply(html, &quot;//span[@class=&#39;ptname &#39;]&quot;, xmlValue) ## list() 除了把HTML檔案當作XML處理外，rvest(Wickham 2019a) package是R語言中最常被使用的爬蟲套件，使用前一樣需要安裝與載入 install.packages(&quot;rvest&quot;) ##安裝 library(rvest) ##載入 載入rvest套件後，經由以下步驟進行網站解析： 使用read_html(“欲擷取的網站網址”)函數讀取網頁 使用html_nodes()函數擷取所需內容 (條件為CSS或xpath標籤) 使用html_text()函數處理/清洗擷取內容，留下需要的資料 使用html_attr()函數擷取資料參數（如連結url） YahooNewsurl=&quot;https://tw.news.yahoo.com/&quot; news_title = read_html(YahooNewsurl) %&gt;% html_nodes(&quot;.tpl-title a&quot;) %&gt;% html_text() news_url = read_html(YahooNewsurl) %&gt;% html_nodes(&quot;.tpl-title a&quot;) %&gt;% html_attr(&quot;href&quot;) Yahoo_news = data.frame(title = news_title, url=news_url) head(Yahoo_news) title url 1 曾1妻5妾好風光 男星慘賣豪宅還債 /從1妻5妾的風光到變賣豪宅還債-網友噓雷洪：活該-091741737.html 2 美報告：美棄「一中」台灣更危險 /美報告-美拋棄-中-台灣處境更危險-081036215.html 3 藍色凍蕃薯！1張圖看寒流有多冷 /霸王級寒流再襲台-張圖看懂這波寒流有多強-101500692.html 4 他被妻子戴綠帽 對象竟是親弟弟 /他被妻子戴綠帽-對象竟是親弟弟-072010033.html 5 匆忙推出移民禁令 他後悔了 /匆忙推移民禁令-美國土安全部長表後悔-044517088.html 6 蔡政府對釣魚台態度 國民黨憂美日安保質變 /蔡政府對釣魚台態度-國民黨憂美日安保質變-160200179.html 在html_nodes()、html_text()和html_attr()函數中，擷取條件的撰寫會因網頁語法不同而有差異，必須要使用Google Chrome開發工具等工具輔助觀察需要擷取資料的條件。以上述Yahoo新聞為例，需要擷取的資料所在HTML片段如下： &lt;ul class=&quot;tpl-title yom-list list-style-none&quot; id=&quot;yui_3_9_1_1_1486568229946_2408&quot;&gt; &lt;li class=&quot;list-story first&quot; id=&quot;yui_3_9_1_1_1486568229946_2407&quot;&gt; &lt;div class=&quot;txt&quot; id=&quot;yui_3_9_1_1_1486568229946_2406&quot;&gt; &lt;a href=&quot;/從1妻5妾的風光到變賣豪宅還債-網友噓雷洪：活該-091741737.html&quot; class=&quot;title &quot; data-ylk=&quot;pkg:96a0ca11-47bc-3100-81ad-0a288707f150;ver:60cdb126-ee0c-11e6-bb9b-8a777738a932;lt:i;pos:1;&quot; data-rapid_p=&quot;1&quot;&gt;曾1妻5妾好風光 男星慘賣豪宅還債&lt;/a&gt; &lt;cite id=&quot;yui_3_9_1_1_1486568229946_2405&quot;&gt; &lt;span class=&quot;provider&quot; id=&quot;yui_3_9_1_1_1486568229946_2404&quot;&gt;Yahoo奇摩娛樂新聞&lt;/span&gt; &lt;/cite&gt;&lt;/div&gt;&lt;/li&gt; .... 觀察上述程式碼可已發現新聞清單被包含在ul標籤下，且css class為tpl-title yom-list list-style-none，所以這邊可以使用第一個classtpl-title為篩選條件。CSS 標籤的意義可參考W3C Schools的教學{target=\"_blank\"}。在此整理常用的語法： CSS Selector 常見語法 參考資料 .xxx：select elements with class=“xxx” #xxx：select elements with id=“xxx” [yyy]：select elements with attribute yyy [yyy=zzz]：select elements with attribute yyy=“zzz” 網頁爬蟲需要多做觀察與練習，才可熟知篩選技巧。 其他爬蟲相關參考資源: 網路爬蟲實作 - 用 r 語言打造自己的爬蟲程式 rvest GitHub R Bloggers 有很多 爬蟲範例（英文） Ptt爬蟲實作 大數學堂 網頁爬蟲課程 搭配結巴中文斷詞的使用範例 5.1 Facebook資料擷取 在2018年的風波後，Graph API若要用在爬取公開粉專，須經過FB審核 Facebook提供Graph API，讓應用程式可透過API讀取與寫入 Facebook相關資料，Graph API會根據篩選條件，回傳JSON格式的資料。除此之外，Facebook還提供Graph API Explorer，讓程式開發人員可以測試資料撈取方法和結果。 在開始使用Graph API之前，必須要取得自己的access token (存取權杖)，Graph API Explorer工具提供Get Token按鈕(通常在視窗右上角)，可以讓開發者在不用新增應用程式(Application)的情況下取得暫時的access token。 有關Facebook access token的詳細介紹，可參考官方文件 5.1.1 Graph API in R library(httr) token&lt;-&quot;your token&quot; #將access token複製到此處 FBData = GET( paste0(&quot;https://graph.facebook.com/v2.8/tsaiingwen?fields=posts%7Bmessage%7D&amp;access_token=&quot;, token)) names(FBData) ## [1] &quot;url&quot; &quot;status_code&quot; &quot;headers&quot; &quot;all_headers&quot; &quot;cookies&quot; &quot;content&quot; &quot;date&quot; ## [8] &quot;times&quot; &quot;request&quot; &quot;handle&quot; json1 = content(FBData) names(json1) ## [1] &quot;posts&quot; &quot;id&quot; names(json1$posts) ## [1] &quot;data&quot; &quot;paging&quot; head(json1$posts$data,3) [[1]] [[1]]$message [1] &quot;「國機國造」不是夢想，而是一個行動。今天啟動的高級教練機「自研自製」任務，是國防自主的重要里程碑。我們不只要讓戰機起飛，更要讓產業起飛。\\n\\n國防產業同樣是「5+2」關鍵產業之一，所以，除了要如期、如質完成新式高教機的「自研自製」外，也要重新厚植台灣的航太工業人才鏈，以及加強相關產業的連結、轉型和升級。\\n\\n國防自主沒有捷徑，只有努力再努力、堅持再堅持。今天，我們重新跨出歷史性的一步。&quot; [[1]]$id [1] &quot;46251501064_10154006497451065&quot; [[2]] [[2]]$message [1] &quot;今天，智慧機械推動辦公室正式啟動。「落實產學合作」、「支持創新研發」、「強化行銷通路」是辦公室的三項重點任務。\\n\\n智慧機械是「5+2」關鍵產業的其中之一。政府有決心。我相信，所有的機械業者－無論做的是螺桿、刀庫、控制器或是工作母機，大家也都有很強的決心，要走向創新、走向智慧化、走向品牌。我們是一個團隊，我們一起加油！&quot; [[2]]$id [1] &quot;46251501064_10154006456601065&quot; [[3]] [[3]]$message [1] &quot;今天來向台商拜個晚年。我也邀請台商朋友們，共同參與台灣經濟轉型升級的世紀工程。\\n\\n無論是擴大對國內的投資，或者配合新南向政策，前進海外深耕佈局，我期待跟台商朋友們一起努力，群策群力，克服困難和瓶頸，為台灣經濟發展打開全新的局面。&quot; [[3]]$id [1] &quot;46251501064_10154001652641065&quot; json1$posts$data[[1]]$message ##[1] &quot;「國機國造」不是夢想，而是一個行動。今天啟動的高級教練機「自研自製」任務，是國防自主的重要里程碑。我們不只要讓戰機起飛，更要讓產業起飛。\\n\\n國防產業同樣是「5+2」關鍵產業之一，所以，除了要如期、如質完成新式高教機的「自研自製」外，也要重新厚植台灣的航太工業人才鏈，以及加強相關產業的連結、轉型和升級。\\n\\n國防自主沒有捷徑，只有努力再努力、堅持再堅持。今天，我們重新跨出歷史性的一步。&quot; 5.1.2 Rfacebook package 在2018年的風波後，Graph API若要用在爬取公開粉專，須經過FB審核 除了直接使用Graph API外，也可使用Rfacebook(Barbera et al. 2017) package來讀取Facebook資料。 以下為使用Rfacebook取得 tsaiingwen 粉絲頁的資料範例： library(Rfacebook) token&lt;-&quot;your token&quot; #將token複製到此處 getPage(&quot;tsaiingwen&quot;, token,n = 5) 5 posts from_id from_name 1 46251501064 蔡英文 Tsai Ing-wen 2 46251501064 蔡英文 Tsai Ing-wen 3 46251501064 蔡英文 Tsai Ing-wen 4 46251501064 蔡英文 Tsai Ing-wen 5 46251501064 蔡英文 Tsai Ing-wen message 1 「國機國造」不是夢想，而是一個行動。今天啟動的高級教練機「自研自製」任務，是國防自主的重要里程碑。我們不只要讓戰機起飛，更要讓產業起飛。\\n\\n國防產業同樣是「5+2」關鍵產業之一，所以，除了要如期、如質完成新式高教機的「自研自製」外，也要重新厚植台灣的航太工業人才鏈，以及加強相關產業的連結、轉型和升級。\\n\\n國防自主沒有捷徑，只有努力再努力、堅持再堅持。今天，我們重新跨出歷史性的一步。 2 今天，智慧機械推動辦公室正式啟動。「落實產學合作」、「支持創新研發」、「強化行銷通路」是辦公室的三項重點任務。\\n\\n智慧機械是「5+2」關鍵產業的其中之一。政府有決心。我相信，所有的機械業者－無論做的是螺桿、刀庫、控制器或是工作母機，大家也都有很強的決心，要走向創新、走向智慧化、走向品牌。我們是一個團隊，我們一起加油！ 3 今天來向台商拜個晚年。我也邀請台商朋友們，共同參與台灣經濟轉型升級的世紀工程。\\n\\n無論是擴大對國內的投資，或者配合新南向政策，前進海外深耕佈局，我期待跟台商朋友們一起努力，群策群力，克服困難和瓶頸，為台灣經濟發展打開全新的局面。 4 「快了」！雞年通機捷，等待很值得。大年初四，我來看看機場捷運通車前的準備，也坐捷運到中壢，跟鄉親拜年問好。 5 雞年初三發福袋\\n\\n臺中豐原慈濟宮、彰化溪湖福安宮、雲林北港朝天宮、嘉義九華山地藏庵 created_time type 1 2017-02-07T08:02:45+0000 photo 2 2017-02-07T07:18:00+0000 photo 3 2017-02-05T07:12:52+0000 photo 4 2017-01-31T08:37:42+0000 photo 5 2017-01-30T11:41:07+0000 photo link 1 https://www.facebook.com/tsaiingwen/photos/a.390960786064.163647.46251501064/10154006497206065/?type=3 2 https://www.facebook.com/tsaiingwen/photos/a.390960786064.163647.46251501064/10154006455396065/?type=3 3 https://www.facebook.com/tsaiingwen/photos/a.390960786064.163647.46251501064/10154001652641065/?type=3 4 https://www.facebook.com/tsaiingwen/photos/a.390960786064.163647.46251501064/10153989357181065/?type=3 5 https://www.facebook.com/tsaiingwen/photos/a.390960786064.163647.46251501064/10153987089121065/?type=3 id likes_count comments_count shares_count 1 46251501064_10154006497451065 2013 125 43 2 46251501064_10154006456601065 2217 163 57 3 46251501064_10154001652641065 9416 920 163 4 46251501064_10153989358051065 34116 1574 373 5 46251501064_10153987095776065 20592 665 269 由於每次擷取資料的比數有上限（大概是30筆左右），如果需要取得更多更長期的資料，就要使用迴圈協助，分批取得資料，透過設定 since 和 until參數，可設定資料擷取區間。 首先先取得日期向量，供後續迴圈做使用 lastDate&lt;-Sys.Date() DateVector&lt;-seq(as.Date(&quot;2017-01-01&quot;),lastDate,by=&quot;5 days&quot;) DateVectorStr&lt;-as.character(DateVector) DateVectorStr ## &quot;2017-01-01&quot; &quot;2017-01-06&quot; &quot;2017-01-11&quot; &quot;2017-01-16&quot; &quot;2017-01-21&quot; &quot;2017-01-26&quot; &quot;2017-01-31&quot; &quot;2017-02-05&quot; 利用上述日期向量資料，搭配迴圈，依序設定since 和 until參數 totalPage&lt;-NULL token&lt;-&#39;your token&#39; numberOfPost&lt;-30 for(i in 1:(length(DateVectorStr)-1)){ tempPage&lt;-getPage(&quot;tsaiingwen&quot;, token, since = DateVectorStr[i],until = DateVectorStr[i+1]) totalPage&lt;-rbind(totalPage,tempPage) } nrow(totalPage) ## 4 posts 8 posts 10 posts 3 posts 2 posts 14 posts 1 posts ## [1] 42 Rfacebook Packages提供其他函數可供使用 getUsers() getPost() searchFacebook() Check https://github.com/pablobarbera/Rfacebook 5.2 資料匯出 在R中完成資料處理後，有多種匯出選擇，如果是要匯出供他人在其他環境(如Excel)使用，建議匯出成tab分隔的文字檔(.txt)或是逗號分隔的文字檔(.csv)；但若是要在R的環境繼續使用，建議匯出成R物件 (.rds)，除了可保留欄位型別設定外，讀取速度與檔案大小皆優於文字檔案。 5.2.1 文字檔 .txt 使用write.table()函數寫入檔案，需要參數有 x 要匯出的檔案，通常為matrix或是data.frame格式 file 檔案名稱 append T/F TRUE表示在檔案後端加入文字，F表示直接覆蓋原始檔案 (預設F) quote 是否需要用雙引號將字串包起 (預設T) sep 分隔符號 (預設空白) eol 換行符號 na 表示空值的字串 dec 小數點表示法 row.names T/F 是否需要輸出row names col.names T/F 是否需要輸出column names qmethod 逃脫字串設定 fileEncoding 編碼設定 write.table(iris,file=&quot;iris.txt&quot;,sep=&quot;,&quot;,row.names = F,col.names = T) 5.2.2 CSV檔 .csv 與write.table()類似，使用write.csv()函數寫入檔案 write.csv(iris,file=&quot;iris.csv&quot;,row.names = F) 5.2.3 R物件 .rds 若是要在R的環境繼續使用，建議匯出成R物件檔案(.rds) saveRDS(iris,&quot;iris.rds&quot;) References "],
["manipulation.html", "6 資料處理與清洗 6.1 Tidy Data 6.2 資料型別轉換處理 6.3 文字字串處理 6.4 子集Subset 6.5 排序 6.6 資料組合 6.7 資料結合 (Join) 6.8 長表與寬表 6.9 遺漏值處理 6.10 綜合練習範例Case study", " 6 資料處理與清洗 6.1 Tidy Data Each column is a variable. Each row is an observation. 一個欄位（Column）內只有一個數值，最好要有凡人看得懂的Column Name 不同的觀察值應該要在不同列（Row） 一張表裡面，有所有分析需要的資料 如果一定要多張表，中間一定要有index可以把表串起來 One file, one table 6.2 資料型別轉換處理 在資料型態章節Chapter 1.5中，曾介紹數值 (numeric)、字串 (character)、布林變數 (logic)以及日期 (Date)等資料型態，在此章節中將介紹如何檢查變數型別與各型別的轉換。 6.2.1 資料型別檢查 使用以下is.函數檢查資料型別，回傳布林變數，若為真，回傳TRUE 是否為數字 is.numeric(變數名稱) 是否為文字 is.character(變數名稱) 是否為布林變數 is.logical(變數名稱) num&lt;-100 cha&lt;-&#39;200&#39; boo&lt;-T is.numeric(num) ## [1] TRUE is.numeric(cha) ## [1] FALSE is.character(num) ## [1] FALSE is.character(cha) ## [1] TRUE is.logical(boo) ## [1] TRUE 或使用class(變數名稱)函數，直接回傳資料型別 class(num) ## [1] &quot;numeric&quot; class(cha) ## [1] &quot;character&quot; class(boo) ## [1] &quot;logical&quot; class(Sys.Date()) ## [1] &quot;Date&quot; 6.2.2 資料型別轉換 使用以下as.函數轉換型別 轉換為數字 as.numeric(變數名稱) 轉換為文字 as.character(變數名稱) 轉換為布林變數 as.logical(變數名稱) as.numeric(cha) ## [1] 200 as.numeric(boo) ## [1] 1 as.character(num) ## [1] &quot;100&quot; as.character(boo) ## [1] &quot;TRUE&quot; 若無法順利完成轉換，會回傳空值NA，並出現警告訊息Warning: NAs introduced by coercion，Warning: 強制變更過程中產生了 NA as.numeric(&quot;abc&quot;) ## Warning: 強制變更過程中產生了 NA ## [1] NA 日期的轉換則建議使用lubridate(Spinu, Grolemund, and Wickham 2020) package，如果想要將年/月/日格式的文字轉換為日期物件，可使用ymd()函數（y表年year，m表月month，d表日day），如果想要將月/日/年格式的文字轉換為日期物件，則使用mdy()函數，以此類推。 library(lubridate) ymd(&#39;2012/3/3&#39;) ## [1] &quot;2012-03-03&quot; mdy(&#39;3/3/2012&#39;) ## [1] &quot;2012-03-03&quot; 6.3 文字字串處理 6.3.1 基本處理 切割 strsplit() 子集 substr() 大小寫轉換 toupper() tolower() 兩文字連接 paste() paste0() 文字取代 gsub() 前後空白去除 str_trim() 需安裝stringr(Wickham 2019b) package strsplit (&quot;Hello World&quot;,&quot; &quot;) ## [[1]] ## [1] &quot;Hello&quot; &quot;World&quot; toupper(&quot;Hello World&quot;) ## [1] &quot;HELLO WORLD&quot; tolower(&quot;Hello World&quot;) ## [1] &quot;hello world&quot; paste(&quot;Hello&quot;, &quot;World&quot;, sep=&#39;&#39;) ## [1] &quot;HelloWorld&quot; substr(&quot;Hello World&quot;, start=2,stop=4) ## [1] &quot;ell&quot; gsub(&quot;o&quot;,&quot;0&quot;,&quot;Hello World&quot;) ## [1] &quot;Hell0 W0rld&quot; library(stringr) str_trim(&quot; Hello World &quot;) ## [1] &quot;Hello World&quot; 6.3.2 搜尋字串 搜尋字串函數通常使用在比對文字向量，文字比對有分大小寫，依照回傳值的型態不同，有兩種常用函數，grep()與grepl(): 回傳符合條件之向量位置(index) grep(搜尋條件,要搜尋的向量) 回傳每個向量是否符合條件(TRUE or FALSE) grepl(搜尋條件,要搜尋的向量) grep(&quot;A&quot;,c(&quot;Alex&quot;,&quot;Tom&quot;,&quot;Amy&quot;,&quot;Joy&quot;,&quot;Emma&quot;)) ##在姓名文字向量中尋找A，回傳包含&quot;A&quot;之元素位置 ## [1] 1 3 grepl(&quot;A&quot;,c(&quot;Alex&quot;,&quot;Tom&quot;,&quot;Amy&quot;,&quot;Joy&quot;,&quot;Emma&quot;)) ##在姓名文字向量中尋找A，回傳各元素是否包含&quot;A&quot; ## [1] TRUE FALSE TRUE FALSE FALSE grepl(&quot;a&quot;,c(&quot;Alex&quot;,&quot;Tom&quot;,&quot;Amy&quot;,&quot;Joy&quot;,&quot;Emma&quot;)) ##在姓名文字向量中尋找a，回傳各元素是否包含&quot;a&quot; ## [1] FALSE FALSE FALSE FALSE TRUE 6.3.3 正規表示式 (Regular Expression) 字串處理通常會搭配正規表示式 (Regular Expression) Regular Expression (正規表示式)是指一組能用來表示字串共同格式 (common structure)的樣式 (Pattern)，像是@符號會固定出現在email中，或是手機號碼固定是10碼，等等樣式。 在所有的程式語言中，只要用到字串比對與字串取代等字串相關功能，都會用到正規表示式。雖然正規表示式在不同程式語言中會有些許差異，但核心概念是相同的。 以下是常見的範例: 語法 正則表達式 範例 整數 [0-9]+ 5815 浮點數 [0-9]+.[0-9]+ 58.15 純英文字串 [A-Za-z]+ CGUIM Email [a-zA-Z0-9_]+@[a-zA-Z0-9._]+ im@mail.cgu.edu.tw URL http://[a-zA-Z0-9./_]+ http://www.is.cgu.edu.tw/ 可以用正規表示式的R函數如下： grep() grepl() gsub() str_split() stringr package中的諸多函數 正規表示式的常用語法分類如下： 逃脫字元 表示數量 表示位置 運算子 特殊符號 6.3.3.1 逃脫字元 **** 6.3.3.2 表示數量的語法 *: 出現0~無限多次 +: 出現1~無限多次 ?: 出現0~1次 {n}: 出現n次 {n,}: 出現n~無限多次 {n,m}: 出現n~m次 stringVector&lt;-c(&quot;a&quot;,&quot;abc&quot;,&quot;ac&quot;,&quot;abbc&quot;,&quot;abbbc&quot;,&quot;abbbbc&quot;) grep(&quot;ab*&quot;,stringVector,value=T) ## [1] &quot;a&quot; &quot;abc&quot; &quot;ac&quot; &quot;abbc&quot; &quot;abbbc&quot; &quot;abbbbc&quot; grep(&quot;ab+&quot;,stringVector,value=T) ## [1] &quot;abc&quot; &quot;abbc&quot; &quot;abbbc&quot; &quot;abbbbc&quot; grep(&quot;ab?c&quot;,stringVector,value=T) ## [1] &quot;abc&quot; &quot;ac&quot; grep(&quot;ab{2}c&quot;,stringVector,value=T) ## [1] &quot;abbc&quot; grep(&quot;ab{2,}c&quot;,stringVector,value=T) ## [1] &quot;abbc&quot; &quot;abbbc&quot; &quot;abbbbc&quot; grep(&quot;ab{2,3}c&quot;,stringVector,value=T) ## [1] &quot;abbc&quot; &quot;abbbc&quot; 6.3.3.3 表示位置的語法 ^: 出現在字串開始的位置 $: 出現在字串結束ˇ的位置 \\b: 出現空字串(空白)開始或結束的位置 \\B: 出現非字串開始或結束的位置 stringVector&lt;-c(&quot;abc&quot;,&quot;bcd&quot;,&quot;cde&quot;,&quot;def&quot;,&quot;abc def&quot;,&quot;bcdefg abc&quot;) grep(&quot;^bc&quot;,stringVector,value=T) ## [1] &quot;bcd&quot; &quot;bcdefg abc&quot; grep(&quot;bc$&quot;,stringVector,value=T) ## [1] &quot;abc&quot; &quot;bcdefg abc&quot; grep(&quot;\\\\bde&quot;,stringVector,value=T) ## [1] &quot;def&quot; &quot;abc def&quot; grep(&quot;\\\\Bde&quot;,stringVector,value=T) ## [1] &quot;cde&quot; &quot;bcdefg abc&quot; 6.3.3.4 運算子 .: 出現所有的字元一次，包括空字串 [...]: 出現字元清單(…)中的字元一次，可用-表示範圍，如[A-Z]，[a-z]，[0-9] [^...]: 不出現字元清單(…)中的字元 \\: 要搜尋字串中的特殊字元時，前方須加上\\ |: 或 stringVector&lt;-c(&quot;03-2118800&quot;,&quot;02-23123456&quot;,&quot;0988123456&quot;, &quot;07-118&quot;,&quot;0-888&quot;,&quot;csim@mail.cgu.edu.tw&quot;,&quot;csim@.&quot;,&quot;csim@&quot;, &quot;http://www.is.cgu.edu.tw/&quot;) grep(&quot;[0-9]{2}-[0-9]{7,8}&quot;,stringVector,value=T) ## [1] &quot;03-2118800&quot; &quot;02-23123456&quot; grep(&quot;[0-9]{10}&quot;,stringVector,value=T) ## [1] &quot;0988123456&quot; grep(&quot;02|03&quot;,stringVector,value=T) ## [1] &quot;03-2118800&quot; &quot;02-23123456&quot; grep(&quot;[a-zA-Z0-9_]+@[a-zA-Z0-9._]+&quot;,stringVector,value=T) ## [1] &quot;csim@mail.cgu.edu.tw&quot; &quot;csim@.&quot; 6.3.3.5 特殊符號 \\d: 數字，等於 [0-9] \\D: 非數字，等於 [^0-9] [:lower:]: 小寫字，等於 [a-z] [:upper:]: 大寫字，等於 [A-Z] [:alpha:]: 所有英文字，等於 [[:lower:][:upper:]] or [A-z] [:alnum:]: 所有英文字和數字，等於 [[:alpha:][:digit:]] or [A-z0-9] \\w: 文字數字與底線，等於 [[:alnum:]_] or [A-z0-9_] \\W: 非文字數字與底線，等於 [^A-z0-9_] [:blank:]: 空白字元，包括空白和tab \\s: 空白字元, \\S: 非空白字元 [:punct:]: 標點符號 ! \" # $ % &amp; ’ ( ) * + , - . / : ; &lt; = &gt; ? @ [ ] ^ _ ` { | } ~. stringVector&lt;-c(&quot;03-2118800&quot;,&quot;02-23123456&quot;,&quot;0988123456&quot;, &quot;07-118&quot;,&quot;0-888&quot;,&quot;csim@mail.cgu.edu.tw&quot;,&quot;http://www.is.cgu.edu.tw/&quot;) grep(&quot;\\\\d{2}-\\\\d{7,8}&quot;,stringVector,value=T) ## [1] &quot;03-2118800&quot; &quot;02-23123456&quot; grep(&quot;\\\\d{10}&quot;,stringVector,value=T) ## [1] &quot;0988123456&quot; grep(&quot;\\\\w+@[a-zA-Z0-9._]+&quot;,stringVector,value=T) ## [1] &quot;csim@mail.cgu.edu.tw&quot; 6.3.3.6 參考資料 Regular Expression 詳論 RegExLib.com Regular Expression in R 6.4 子集Subset 6.4.1 一維資料 (向量) 在向量章節{#vector}有介紹使用[]取出單一或多個元素的方法 letters ##R語言內建資料之一 ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; ## [20] &quot;t&quot; &quot;u&quot; &quot;v&quot; &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; letters[1] ##取出letters向量的第一個元素 ## [1] &quot;a&quot; letters[1:10] ##取出letters向量的前十個元素 ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; letters[c(1,3,5)] ##取出letters向量的第1,3,5個元素 ## [1] &quot;a&quot; &quot;c&quot; &quot;e&quot; letters[c(-1,-3,-5)] ##取出letters向量除了第1,3,5個元素之外的所有元素 ## [1] &quot;b&quot; &quot;d&quot; &quot;f&quot; &quot;g&quot; &quot;h&quot; &quot;i&quot; &quot;j&quot; &quot;k&quot; &quot;l&quot; &quot;m&quot; &quot;n&quot; &quot;o&quot; &quot;p&quot; &quot;q&quot; &quot;r&quot; &quot;s&quot; &quot;t&quot; &quot;u&quot; &quot;v&quot; ## [20] &quot;w&quot; &quot;x&quot; &quot;y&quot; &quot;z&quot; 若想要快速取得一向量的開頭與結尾元素，可使用head()和tail()函數 head(letters,5) ##取出letters向量的前五個元素 ## [1] &quot;a&quot; &quot;b&quot; &quot;c&quot; &quot;d&quot; &quot;e&quot; tail(letters,3) ##取出letters向量的後三個元素 ## [1] &quot;x&quot; &quot;y&quot; &quot;z&quot; 6.4.2 二維資料 最常見的二維資料為data.frame資料框，二維資料可針對列(Row)和行(Column)做子集，子集選擇方式一樣是使用[]，但因應二維資料的需求，以,分隔列與行的篩選條件，資料篩選原則為前Row,後Column，前列,後行，若不想篩選列，則在,前方保持空白即可。 篩選方式可輸入位置(index)、欄位名稱或輸入布林變數(TRUE/FALSE) 輸入位置: dataFrame[row index,column index] 輸入布林變數: dataFrame[c(T,F,T),c(T,F,T)] 輸入欄位名稱: dataFrame[row name,column name] data(iris) iris[1,2] ##第一列Row，第二行Column ## [1] 3.5 iris[1:3,] ##第1~3列Row，所有的行Column ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa iris[,&quot;Species&quot;] ##所有的列Row，名稱為Species的行Column ## [1] setosa setosa setosa setosa setosa setosa ## [7] setosa setosa setosa setosa setosa setosa ## [13] setosa setosa setosa setosa setosa setosa ## [19] setosa setosa setosa setosa setosa setosa ## [25] setosa setosa setosa setosa setosa setosa ## [31] setosa setosa setosa setosa setosa setosa ## [37] setosa setosa setosa setosa setosa setosa ## [43] setosa setosa setosa setosa setosa setosa ## [49] setosa setosa versicolor versicolor versicolor versicolor ## [55] versicolor versicolor versicolor versicolor versicolor versicolor ## [61] versicolor versicolor versicolor versicolor versicolor versicolor ## [67] versicolor versicolor versicolor versicolor versicolor versicolor ## [73] versicolor versicolor versicolor versicolor versicolor versicolor ## [79] versicolor versicolor versicolor versicolor versicolor versicolor ## [85] versicolor versicolor versicolor versicolor versicolor versicolor ## [91] versicolor versicolor versicolor versicolor versicolor versicolor ## [97] versicolor versicolor versicolor versicolor virginica virginica ## [103] virginica virginica virginica virginica virginica virginica ## [109] virginica virginica virginica virginica virginica virginica ## [115] virginica virginica virginica virginica virginica virginica ## [121] virginica virginica virginica virginica virginica virginica ## [127] virginica virginica virginica virginica virginica virginica ## [133] virginica virginica virginica virginica virginica virginica ## [139] virginica virginica virginica virginica virginica virginica ## [145] virginica virginica virginica virginica virginica virginica ## Levels: setosa versicolor virginica iris[1:10,c(T,F,T,F,T)] ##第1~10列Row，第1,3,5行Column (TRUE) ## Sepal.Length Petal.Length Species ## 1 5.1 1.4 setosa ## 2 4.9 1.4 setosa ## 3 4.7 1.3 setosa ## 4 4.6 1.5 setosa ## 5 5.0 1.4 setosa ## 6 5.4 1.7 setosa ## 7 4.6 1.4 setosa ## 8 5.0 1.5 setosa ## 9 4.4 1.4 setosa ## 10 4.9 1.5 setosa 也可使用$符號做Column的篩選 iris$Species ##所有的列Row，名稱為Species的行Column ## [1] setosa setosa setosa setosa setosa setosa ## [7] setosa setosa setosa setosa setosa setosa ## [13] setosa setosa setosa setosa setosa setosa ## [19] setosa setosa setosa setosa setosa setosa ## [25] setosa setosa setosa setosa setosa setosa ## [31] setosa setosa setosa setosa setosa setosa ## [37] setosa setosa setosa setosa setosa setosa ## [43] setosa setosa setosa setosa setosa setosa ## [49] setosa setosa versicolor versicolor versicolor versicolor ## [55] versicolor versicolor versicolor versicolor versicolor versicolor ## [61] versicolor versicolor versicolor versicolor versicolor versicolor ## [67] versicolor versicolor versicolor versicolor versicolor versicolor ## [73] versicolor versicolor versicolor versicolor versicolor versicolor ## [79] versicolor versicolor versicolor versicolor versicolor versicolor ## [85] versicolor versicolor versicolor versicolor versicolor versicolor ## [91] versicolor versicolor versicolor versicolor versicolor versicolor ## [97] versicolor versicolor versicolor versicolor virginica virginica ## [103] virginica virginica virginica virginica virginica virginica ## [109] virginica virginica virginica virginica virginica virginica ## [115] virginica virginica virginica virginica virginica virginica ## [121] virginica virginica virginica virginica virginica virginica ## [127] virginica virginica virginica virginica virginica virginica ## [133] virginica virginica virginica virginica virginica virginica ## [139] virginica virginica virginica virginica virginica virginica ## [145] virginica virginica virginica virginica virginica virginica ## Levels: setosa versicolor virginica Row的篩選可使用subset()函數，使用方法為subset(資料表,篩選邏輯) subset(iris,Species==&quot;virginica&quot;) ##Species等於&quot;virginica&quot;的列Row，所有的行Column ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 101 6.3 3.3 6.0 2.5 virginica ## 102 5.8 2.7 5.1 1.9 virginica ## 103 7.1 3.0 5.9 2.1 virginica ## 104 6.3 2.9 5.6 1.8 virginica ## 105 6.5 3.0 5.8 2.2 virginica ## 106 7.6 3.0 6.6 2.1 virginica ## 107 4.9 2.5 4.5 1.7 virginica ## 108 7.3 2.9 6.3 1.8 virginica ## 109 6.7 2.5 5.8 1.8 virginica ## 110 7.2 3.6 6.1 2.5 virginica ## 111 6.5 3.2 5.1 2.0 virginica ## 112 6.4 2.7 5.3 1.9 virginica ## 113 6.8 3.0 5.5 2.1 virginica ## 114 5.7 2.5 5.0 2.0 virginica ## 115 5.8 2.8 5.1 2.4 virginica ## 116 6.4 3.2 5.3 2.3 virginica ## 117 6.5 3.0 5.5 1.8 virginica ## 118 7.7 3.8 6.7 2.2 virginica ## 119 7.7 2.6 6.9 2.3 virginica ## 120 6.0 2.2 5.0 1.5 virginica ## 121 6.9 3.2 5.7 2.3 virginica ## 122 5.6 2.8 4.9 2.0 virginica ## 123 7.7 2.8 6.7 2.0 virginica ## 124 6.3 2.7 4.9 1.8 virginica ## 125 6.7 3.3 5.7 2.1 virginica ## 126 7.2 3.2 6.0 1.8 virginica ## 127 6.2 2.8 4.8 1.8 virginica ## 128 6.1 3.0 4.9 1.8 virginica ## 129 6.4 2.8 5.6 2.1 virginica ## 130 7.2 3.0 5.8 1.6 virginica ## 131 7.4 2.8 6.1 1.9 virginica ## 132 7.9 3.8 6.4 2.0 virginica ## 133 6.4 2.8 5.6 2.2 virginica ## 134 6.3 2.8 5.1 1.5 virginica ## 135 6.1 2.6 5.6 1.4 virginica ## 136 7.7 3.0 6.1 2.3 virginica ## 137 6.3 3.4 5.6 2.4 virginica ## 138 6.4 3.1 5.5 1.8 virginica ## 139 6.0 3.0 4.8 1.8 virginica ## 140 6.9 3.1 5.4 2.1 virginica ## 141 6.7 3.1 5.6 2.4 virginica ## 142 6.9 3.1 5.1 2.3 virginica ## 143 5.8 2.7 5.1 1.9 virginica ## 144 6.8 3.2 5.9 2.3 virginica ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica Row的篩選也可搭配字串搜尋函數grepl() knitr::kable(iris[grepl(&quot;color&quot;,iris$Species),]) ##Species包含&quot;color&quot;的列，所有的行 Sepal.Length Sepal.Width Petal.Length Petal.Width Species 51 7.0 3.2 4.7 1.4 versicolor 52 6.4 3.2 4.5 1.5 versicolor 53 6.9 3.1 4.9 1.5 versicolor 54 5.5 2.3 4.0 1.3 versicolor 55 6.5 2.8 4.6 1.5 versicolor 56 5.7 2.8 4.5 1.3 versicolor 57 6.3 3.3 4.7 1.6 versicolor 58 4.9 2.4 3.3 1.0 versicolor 59 6.6 2.9 4.6 1.3 versicolor 60 5.2 2.7 3.9 1.4 versicolor 61 5.0 2.0 3.5 1.0 versicolor 62 5.9 3.0 4.2 1.5 versicolor 63 6.0 2.2 4.0 1.0 versicolor 64 6.1 2.9 4.7 1.4 versicolor 65 5.6 2.9 3.6 1.3 versicolor 66 6.7 3.1 4.4 1.4 versicolor 67 5.6 3.0 4.5 1.5 versicolor 68 5.8 2.7 4.1 1.0 versicolor 69 6.2 2.2 4.5 1.5 versicolor 70 5.6 2.5 3.9 1.1 versicolor 71 5.9 3.2 4.8 1.8 versicolor 72 6.1 2.8 4.0 1.3 versicolor 73 6.3 2.5 4.9 1.5 versicolor 74 6.1 2.8 4.7 1.2 versicolor 75 6.4 2.9 4.3 1.3 versicolor 76 6.6 3.0 4.4 1.4 versicolor 77 6.8 2.8 4.8 1.4 versicolor 78 6.7 3.0 5.0 1.7 versicolor 79 6.0 2.9 4.5 1.5 versicolor 80 5.7 2.6 3.5 1.0 versicolor 81 5.5 2.4 3.8 1.1 versicolor 82 5.5 2.4 3.7 1.0 versicolor 83 5.8 2.7 3.9 1.2 versicolor 84 6.0 2.7 5.1 1.6 versicolor 85 5.4 3.0 4.5 1.5 versicolor 86 6.0 3.4 4.5 1.6 versicolor 87 6.7 3.1 4.7 1.5 versicolor 88 6.3 2.3 4.4 1.3 versicolor 89 5.6 3.0 4.1 1.3 versicolor 90 5.5 2.5 4.0 1.3 versicolor 91 5.5 2.6 4.4 1.2 versicolor 92 6.1 3.0 4.6 1.4 versicolor 93 5.8 2.6 4.0 1.2 versicolor 94 5.0 2.3 3.3 1.0 versicolor 95 5.6 2.7 4.2 1.3 versicolor 96 5.7 3.0 4.2 1.2 versicolor 97 5.7 2.9 4.2 1.3 versicolor 98 6.2 2.9 4.3 1.3 versicolor 99 5.1 2.5 3.0 1.1 versicolor 100 5.7 2.8 4.1 1.3 versicolor 若想要快速取得資料框的前幾列(Row)或後幾列，也可使用head()和tail()函數 head(iris,5) ##取出iris資料框的前五列 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa tail(iris,3) ##取出iris資料框的後三列 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica 6.5 排序 6.5.1 sort 向量排序 sort()函數可直接對向量做由小到大的排序 head(islands) ##排序前的前六筆資料 ## Africa Antarctica Asia Australia Axel Heiberg Baffin ## 11506 5500 16988 2968 16 184 head(sort(islands)) ##由小到大排序後的前六筆資料 ## Vancouver Hainan Prince of Wales Timor Kyushu ## 12 13 13 13 14 ## Taiwan ## 14 如需由大到小排序，可將decreasing參數設為TRUE head(sort(islands,decreasing = T)) ##由大到小排序後的前六筆資料 ## Asia Africa North America South America Antarctica ## 16988 11506 9390 6795 5500 ## Europe ## 3745 6.5.2 order 如需對資料框做排序，可使用order()函數，order()函數可回傳由小到大之元素位置，以iris$Sepal.Length為例，回傳的第一個位置為14，表示iris$Sepal.Length中，數值最小的元素為第14個元素。 order(iris$Sepal.Length) ## [1] 14 9 39 43 42 4 7 23 48 3 30 12 13 25 31 46 2 10 ## [19] 35 38 58 107 5 8 26 27 36 41 44 50 61 94 1 18 20 22 ## [37] 24 40 45 47 99 28 29 33 60 49 6 11 17 21 32 85 34 37 ## [55] 54 81 82 90 91 65 67 70 89 95 122 16 19 56 80 96 97 100 ## [73] 114 15 68 83 93 102 115 143 62 71 150 63 79 84 86 120 139 64 ## [91] 72 74 92 128 135 69 98 127 149 57 73 88 101 104 124 134 137 147 ## [109] 52 75 112 116 129 133 138 55 105 111 117 148 59 76 66 78 87 109 ## [127] 125 141 145 146 77 113 144 53 121 140 142 51 103 110 126 130 108 131 ## [145] 106 118 119 123 136 132 iris$Sepal.Length[14] ## [1] 4.3 若將decreasing參數設定為TRUE，則會回傳由大到小的元素位置，以iris$Sepal.Length為例，回傳的第一個位置為132，表示iris$Sepal.Length中，數值最大的元素為第132個元素。 order(iris$Sepal.Length,decreasing = T) ## [1] 132 118 119 123 136 106 131 108 110 126 130 103 51 53 121 140 142 77 ## [19] 113 144 66 78 87 109 125 141 145 146 59 76 55 105 111 117 148 52 ## [37] 75 112 116 129 133 138 57 73 88 101 104 124 134 137 147 69 98 127 ## [55] 149 64 72 74 92 128 135 63 79 84 86 120 139 62 71 150 15 68 ## [73] 83 93 102 115 143 16 19 56 80 96 97 100 114 65 67 70 89 95 ## [91] 122 34 37 54 81 82 90 91 6 11 17 21 32 85 49 28 29 33 ## [109] 60 1 18 20 22 24 40 45 47 99 5 8 26 27 36 41 44 50 ## [127] 61 94 2 10 35 38 58 107 12 13 25 31 46 3 30 4 7 23 ## [145] 48 42 9 39 43 14 iris$Sepal.Length[132] ## [1] 7.9 依照order回傳的元素位置，重新排序iris資料框 head(iris) ##排序前的前六筆資料 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 1 5.1 3.5 1.4 0.2 setosa ## 2 4.9 3.0 1.4 0.2 setosa ## 3 4.7 3.2 1.3 0.2 setosa ## 4 4.6 3.1 1.5 0.2 setosa ## 5 5.0 3.6 1.4 0.2 setosa ## 6 5.4 3.9 1.7 0.4 setosa head(iris[order(iris$Sepal.Length),]) ##依照Sepal.Length欄位數值大小排序後的前六筆資料 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 14 4.3 3.0 1.1 0.1 setosa ## 9 4.4 2.9 1.4 0.2 setosa ## 39 4.4 3.0 1.3 0.2 setosa ## 43 4.4 3.2 1.3 0.2 setosa ## 42 4.5 2.3 1.3 0.3 setosa ## 4 4.6 3.1 1.5 0.2 setosa head(iris[order(iris$Sepal.Length,decreasing = T),]) ##改為由大到小排序的前六筆資料 ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 132 7.9 3.8 6.4 2.0 virginica ## 118 7.7 3.8 6.7 2.2 virginica ## 119 7.7 2.6 6.9 2.3 virginica ## 123 7.7 2.8 6.7 2.0 virginica ## 136 7.7 3.0 6.1 2.3 virginica ## 106 7.6 3.0 6.6 2.1 virginica 6.6 資料組合 有時需要在資料框新增一列，或新增一行，可以利用資料組合函數完成 Row 列的組合 rbind() Column 行的組合 cbind() rbind()和cbind()的參數可以是向量，也可以是資料框，使用向量做資料整合範例: rbind(c(1,2,3), #第一列 c(4,5,6) #第二列 ) ## [,1] [,2] [,3] ## [1,] 1 2 3 ## [2,] 4 5 6 使用資料框與向量做資料整合範例: irisAdd&lt;-rbind(iris, #資料框 c(1,1,1,1,&quot;versicolor&quot;) #新增一列 ) tail(irisAdd) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 146 6.7 3 5.2 2.3 virginica ## 147 6.3 2.5 5 1.9 virginica ## 148 6.5 3 5.2 2 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3 5.1 1.8 virginica ## 151 1 1 1 1 versicolor 使用向量做資料整合範例: cbind(c(1,2,3), #第一行 c(4,5,6) #第二行 ) ## [,1] [,2] ## [1,] 1 4 ## [2,] 2 5 ## [3,] 3 6 使用資料框與向量做資料整合範例: irisAdd&lt;-cbind(iris, #資料框 rep(&quot;Add&quot;,nrow(iris)) #新增一行 ) tail(irisAdd) ## Sepal.Length Sepal.Width Petal.Length Petal.Width Species ## 145 6.7 3.3 5.7 2.5 virginica ## 146 6.7 3.0 5.2 2.3 virginica ## 147 6.3 2.5 5.0 1.9 virginica ## 148 6.5 3.0 5.2 2.0 virginica ## 149 6.2 3.4 5.4 2.3 virginica ## 150 5.9 3.0 5.1 1.8 virginica ## rep(&quot;Add&quot;, nrow(iris)) ## 145 Add ## 146 Add ## 147 Add ## 148 Add ## 149 Add ## 150 Add 6.7 資料結合 (Join) 除了按照行列順序的組合外，更常有的情形是依照某個欄位的值作為結合依據，如： 用學號把以下兩個資料框結合成一個資料框 學號與姓名資料框 學號與宿舍床位資料框 用縣市名稱與年度將人口資料與醫療資源資料結合 原生的R環境可以用merge()函數將資料框結合，使用方法為merge(資料框1,資料框2,by=\"結合依據欄位\") nameDF&lt;-data.frame(ID=c(1,2,3,4,5), Name=c(&quot;Amy&quot;,&quot;Bob&quot;,&quot;Chris&quot;,&quot;David&quot;,&quot;Emma&quot;)) scoreDF&lt;-data.frame(ID=c(1,2,4), Score=c(60,90,50)) nameDF ID Name 1 Amy 2 Bob 3 Chris 4 David 5 Emma scoreDF ID Score 1 60 2 90 4 50 merge(nameDF,scoreDF,by=&quot;ID&quot;) ID Name Score 1 Amy 60 2 Bob 90 4 David 50 按照上述輸出結果可知，merge函數預設只保留兩資料框都有對應到的資料，如果不想要merge函數將沒對應到的資料刪除，可以設定參數all，all.x或是all.y，來保留沒對應到的資料列。 merge(資料框1,資料框2,by=\"結合依據欄位\",all=T) merge(資料框1,資料框2,by=\"結合依據欄位\",all.x=T) merge(資料框1,資料框2,by=\"結合依據欄位\",all.y=T) merge(nameDF,scoreDF,by=&quot;ID&quot;,all=T) ID Name Score 1 Amy 60 2 Bob 90 3 Chris NA 4 David 50 5 Emma NA dplyr套件提供更有效率的資料結合方法，包括: inner_join()：保留有對應到的資料 left_join()：保留左邊資料框的所有資料 right_join()：保留右邊資料框的所有資料 full_join()：保留所有資料 semi_join() anti_join() inner_join()：只保留兩張表都有的列，使用方法為 inner_join(x, y, by = ) library(dplyr) #使用前須先載入套件 inner_join(nameDF,scoreDF,by=&quot;ID&quot;) ## ID Name Score ## 1 1 Amy 60 ## 2 2 Bob 90 ## 3 4 David 50 left_join()：保留左邊的表所有的列，使用方法文為 left_join(x, y, by = ) left_join(nameDF,scoreDF,by=&quot;ID&quot;) ## ID Name Score ## 1 1 Amy 60 ## 2 2 Bob 90 ## 3 3 Chris NA ## 4 4 David 50 ## 5 5 Emma NA right_join()：保留右邊的表所有的列。使用方法為 right_join(x, y, by = ) right_join(nameDF,scoreDF,by=&quot;ID&quot;) ## ID Name Score ## 1 1 Amy 60 ## 2 2 Bob 90 ## 3 4 David 50 full_join()：保留所有的列。使用方法為 full_join(x, y, by = ) full_join(nameDF,scoreDF,by=&quot;ID&quot;) ## ID Name Score ## 1 1 Amy 60 ## 2 2 Bob 90 ## 3 3 Chris NA ## 4 4 David 50 ## 5 5 Emma NA semi_join()：留下左邊的ID也有出現在右邊的表的列，右表資料不會輸出。使用方法為 semi_join(x, y, by = ) semi_join(nameDF,scoreDF,by=&quot;ID&quot;) ## ID Name ## 1 1 Amy ## 2 2 Bob ## 3 4 David 6.8 長表與寬表 在資料處理的過程中，常因各種需求，需要執行長寬表互換的動作，在R中有很好用的套件reshape2(Wickham 2020) package，提供完整的轉換功能，最常使用的是 寬表轉長表 melt(資料框/寬表,id.vars=需要保留的欄位) 長表轉寬表 dcast(資料框/長表,寬表分列依據~分欄位依據) 原來的airquality資料框中，有Ozone, Solar.R, Wind, Temp, Month, Day等六個欄位 (Column)，屬於寬表，以下範例將保留Month和Day兩個欄位，並將其他欄位的名稱整合至variable欄位，數值整合至value欄位，寬表轉長表範例如下: library(reshape2) head(airquality) ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 5 NA NA 14.3 56 5 5 ## 6 28 NA 14.9 66 5 6 airqualityM&lt;-melt(airquality,id.vars = c(&quot;Month&quot;,&quot;Day&quot;)) ##欄位需要保留&quot;Month&quot;,&quot;Day&quot; head(airqualityM) ## Month Day variable value ## 1 5 1 Ozone 41 ## 2 5 2 Ozone 36 ## 3 5 3 Ozone 12 ## 4 5 4 Ozone 18 ## 5 5 5 Ozone NA ## 6 5 6 Ozone 28 轉換過的長表airqualityM資料框中，剩下Month, Day, variable, value等四個欄位 (Column)，屬於長表，以下範例variable欄位的值轉換為新欄位，並將value欄位填回新增的欄位，長表轉寬表範例如下: library(reshape2) ##欄位保留&quot;Month&quot;,&quot;Day&quot;外，其他欄位數目由variable定義 airqualityCast&lt;-dcast(airqualityM, Month +Day~variable) head(airqualityCast) ## Month Day Ozone Solar.R Wind Temp ## 1 5 1 41 190 7.4 67 ## 2 5 2 36 118 8.0 72 ## 3 5 3 12 149 12.6 74 ## 4 5 4 18 313 11.5 62 ## 5 5 5 NA NA 14.3 56 ## 6 5 6 28 NA 14.9 66 tidyverse套件組的tidyr (Wickham and Henry 2020) package，也提供完整的轉換功能，舉例如下 寬表轉長表 gather(資料框/寬表,key=\"主鍵欄位名稱\",value=\"數值欄位名稱\",要轉換的資料1,要轉換的資料2,...) 長表轉寬表 spread(資料框/長表,key=\"要展開的欄位名稱\",value=\"數值欄位名稱\") 同上，以airquality資料框為例，原來的airquality資料框中，有Ozone, Solar.R, Wind, Temp, Month, Day等六個欄位 (Column)，屬於寬表 head(airquality,3) ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 以下範例將保留Month和Day兩個欄位，將其他欄位的名稱整合至Type欄位，數值整合至Value欄位，寬表轉長表範例如下: library(tidyr) airqualityL&lt;-gather(airquality, key=Type,value=Value, Ozone,Solar.R,Wind,Temp) ##欄位Ozone,Solar.R,Wind,Temp轉成單一欄位 轉換過的長表airqualityL資料框中，剩下Month, Day, Type, Value等四個欄位 (Column)，屬於長表，以下範例Type欄位的值轉換為新欄位，並將Value欄位填回新增的欄位，長表轉寬表範例如下: #欄位保留&quot;Month&quot;,&quot;Day&quot;外，其他欄位由variable定義 airqualityW&lt;-spread(airqualityL, key=Type,value=Value) head(airqualityW) ## Month Day Ozone Solar.R Temp Wind ## 1 5 1 41 190 67 7.4 ## 2 5 2 36 118 72 8.0 ## 3 5 3 12 149 74 12.6 ## 4 5 4 18 313 62 11.5 ## 5 5 5 NA NA 56 14.3 ## 6 5 6 28 NA 66 14.9 6.9 遺漏值處理 遺漏值(Missing Value)常常出現在真實資料內，在數值運算時常會有問題，最簡單的方法是將有缺值的資料移除，如資料為向量，可使用is.na()來判斷資料是否為空值NA，若為真TRUE，則將資料移除。 naVec&lt;-c(&quot;a&quot;,&quot;b&quot;,NA,&quot;d&quot;,&quot;e&quot;) is.na(naVec) ## [1] FALSE FALSE TRUE FALSE FALSE naVec[!is.na(naVec)] ##保留所有在is.na()檢查回傳FALSE的元素 ## [1] &quot;a&quot; &quot;b&quot; &quot;d&quot; &quot;e&quot; 若資料型態為資料框，可使用complete.cases來選出完整的資料列，如果資料列是完整的，則會回傳真TRUE head(airquality) ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 5 NA NA 14.3 56 5 5 ## 6 28 NA 14.9 66 5 6 complete.cases(airquality) ## [1] TRUE TRUE TRUE TRUE FALSE FALSE TRUE TRUE TRUE FALSE FALSE TRUE ## [13] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [25] FALSE FALSE FALSE TRUE TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE ## [37] FALSE TRUE FALSE TRUE TRUE FALSE FALSE TRUE FALSE FALSE TRUE TRUE ## [49] TRUE TRUE TRUE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE ## [61] FALSE TRUE TRUE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE FALSE ## [73] TRUE TRUE FALSE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE FALSE ## [85] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE FALSE ## [97] FALSE FALSE TRUE TRUE TRUE FALSE FALSE TRUE TRUE TRUE FALSE TRUE ## [109] TRUE TRUE TRUE TRUE TRUE TRUE FALSE TRUE TRUE TRUE FALSE TRUE ## [121] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [133] TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE TRUE ## [145] TRUE TRUE TRUE TRUE TRUE FALSE TRUE TRUE TRUE head(airquality[complete.cases(airquality),]) ##保留所有在complete.cases()檢查回傳TRUE的元素 ## Ozone Solar.R Wind Temp Month Day ## 1 41 190 7.4 67 5 1 ## 2 36 118 8.0 72 5 2 ## 3 12 149 12.6 74 5 3 ## 4 18 313 11.5 62 5 4 ## 7 23 299 8.6 65 5 7 ## 8 19 99 13.8 59 5 8 利用演算法補值也是一種解決辦法，可參考_skydome20_的R筆記–(10)遺漏值處理(Impute Missing Value)教學。 6.10 綜合練習範例Case study 在本範例中，介紹使用SportsAnalytics (Eugster 2013) package 撈取NBA各球員的數據，並加以觀察分析。 6.10.1 載入資料 首先用library()函數將SportsAnalytics套件載入 (若尚未安裝此套件者，必須先安裝套件，可參考Chapter 1)，並利用套件內提供的fetch_NBAPlayerStatistics()函數，將對應年份之資料取出。 library(SportsAnalytics) NBA1516&lt;-fetch_NBAPlayerStatistics(&quot;15-16&quot;) 6.10.2 資料總覽 資料取出後，可用str()函數總覽NBA1516這個資料框的欄位與欄位類別 str(NBA1516) ## &#39;data.frame&#39;: 476 obs. of 25 variables: ## $ League : Factor w/ 1 level &quot;NBA&quot;: 1 1 1 1 1 1 1 1 1 1 ... ## $ Name : chr &quot;Quincy Acy&quot; &quot;Jordan Adams&quot; &quot;Steven Adams&quot; &quot;Arron Afflalo&quot; ... ## $ Team : Factor w/ 31 levels &quot;ATL&quot;,&quot;BOS&quot;,&quot;BRO&quot;,..: 27 15 22 20 19 13 28 26 12 15 ... ## $ Position : Factor w/ 5 levels &quot;C&quot;,&quot;PF&quot;,&quot;PG&quot;,..: 4 5 1 5 1 1 2 2 2 5 ... ## $ GamesPlayed : int 59 2 80 71 59 60 74 9 79 64 ... ## $ TotalMinutesPlayed : int 877 15 2019 2359 863 802 2260 37 1601 1622 ... ## $ FieldGoalsMade : int 119 2 261 354 150 134 536 5 191 215 ... ## $ FieldGoalsAttempted: int 214 6 426 799 314 225 1045 10 370 469 ... ## $ ThreesMade : int 19 0 0 91 0 0 0 0 0 15 ... ## $ ThreesAttempted : int 49 1 0 238 1 0 16 0 0 42 ... ## $ FreeThrowsMade : int 50 3 114 110 52 60 259 0 46 90 ... ## $ FreeThrowsAttempted: int 68 5 196 131 62 84 302 0 73 138 ... ## $ OffensiveRebounds : int 65 0 218 23 75 86 175 2 162 104 ... ## $ TotalRebounds : int 188 2 531 266 269 288 631 6 424 297 ... ## $ Assists : int 27 3 61 145 32 50 110 0 76 70 ... ## $ Steals : int 29 3 42 25 19 47 38 1 26 109 ... ## $ Turnovers : int 27 2 84 82 54 64 99 1 69 78 ... ## $ Blocks : int 24 0 89 10 36 68 81 2 42 18 ... ## $ PersonalFouls : int 103 2 223 142 134 139 151 1 147 175 ... ## $ Disqualifications : int 0 0 2 1 0 1 0 0 1 1 ... ## $ TotalPoints : int 307 7 636 909 352 328 1331 10 428 535 ... ## $ Technicals : int 3 0 2 1 2 0 0 0 0 1 ... ## $ Ejections : int 0 0 0 0 0 0 0 0 0 0 ... ## $ FlagrantFouls : int 0 0 0 0 0 0 0 0 0 0 ... ## $ GamesStarted : int 29 0 80 57 17 5 74 0 28 56 ... 可以發現此NBA1516資料框內有476筆球員資料(觀察值, obs)，每筆資料有25個欄位 (variables)。 6.10.3 資料預覽 如果想看資料框內容，可用head()和tail()快速瀏覽部分資料 head(NBA1516) ## League Name Team Position GamesPlayed TotalMinutesPlayed ## 1 NBA Quincy Acy SAC SF 59 877 ## 2 NBA Jordan Adams MEM SG 2 15 ## 3 NBA Steven Adams OKL C 80 2019 ## 4 NBA Arron Afflalo NYK SG 71 2359 ## 5 NBA Alexis Ajinca NOR C 59 863 ## 6 NBA Cole Aldrich LAC C 60 802 ## FieldGoalsMade FieldGoalsAttempted ThreesMade ThreesAttempted FreeThrowsMade ## 1 119 214 19 49 50 ## 2 2 6 0 1 3 ## 3 261 426 0 0 114 ## 4 354 799 91 238 110 ## 5 150 314 0 1 52 ## 6 134 225 0 0 60 ## FreeThrowsAttempted OffensiveRebounds TotalRebounds Assists Steals Turnovers ## 1 68 65 188 27 29 27 ## 2 5 0 2 3 3 2 ## 3 196 218 531 61 42 84 ## 4 131 23 266 145 25 82 ## 5 62 75 269 32 19 54 ## 6 84 86 288 50 47 64 ## Blocks PersonalFouls Disqualifications TotalPoints Technicals Ejections ## 1 24 103 0 307 3 0 ## 2 0 2 0 7 0 0 ## 3 89 223 2 636 2 0 ## 4 10 142 1 909 1 0 ## 5 36 134 0 352 2 0 ## 6 68 139 1 328 0 0 ## FlagrantFouls GamesStarted ## 1 0 29 ## 2 0 0 ## 3 0 80 ## 4 0 57 ## 5 0 17 ## 6 0 5 6.10.4 資料排序後篩選 觀察資料框的組成後，我們想要找出出場數最高的前五名選手的所有資料，此時可以利用order()函數先由大到小排序(decreasing = T)後，再用[,]取子集。 NBA1516Order&lt;-NBA1516[order(NBA1516$GamesPlayed,decreasing = T),] NBA1516Order[1:5,] ##逗號前方放1~5，表示取1~5列；逗號後方空白，表示要取所有欄位 ## League Name Team Position GamesPlayed TotalMinutesPlayed ## 11 NBA Al-farouq Aminu POR SF 82 2342 ## 37 NBA Will Barton DEN SG 82 2355 ## 48 NBA Bismack Biyombo TOR PF 82 1810 ## 62 NBA Corey Brewer HOU SG 82 1670 ## 118 NBA Gorgui Dieng MIN C 82 2222 ## FieldGoalsMade FieldGoalsAttempted ThreesMade ThreesAttempted ## 11 299 719 126 349 ## 37 426 984 112 324 ## 48 156 288 0 1 ## 62 212 552 61 225 ## 118 308 578 6 20 ## FreeThrowsMade FreeThrowsAttempted OffensiveRebounds TotalRebounds Assists ## 11 115 156 98 498 138 ## 37 216 268 60 477 204 ## 48 142 226 182 655 29 ## 62 105 140 42 199 109 ## 118 205 248 156 584 143 ## Steals Turnovers Blocks PersonalFouls Disqualifications TotalPoints ## 11 72 120 53 171 0 839 ## 37 71 139 39 147 0 1180 ## 48 19 71 133 225 2 454 ## 62 84 78 19 168 1 590 ## 118 94 140 96 219 0 827 ## Technicals Ejections FlagrantFouls GamesStarted ## 11 3 0 0 82 ## 37 2 0 0 1 ## 48 3 0 0 22 ## 62 0 0 0 12 ## 118 1 0 0 39 如果我們想要出出場分鐘數最高的前十名選手的名字，一樣可以用order()函數先由大到小排序(decreasing = T)後，再用[,]取子集。 NBA1516OrderM&lt;-NBA1516[order(NBA1516$TotalMinutesPlayed,decreasing = T),] NBA1516OrderM[1:10,&quot;Name&quot;] ##逗號前方取1~10列；逗號後方放&quot;Name&quot;，表示取名稱為Name之欄位 ## [1] &quot;James Harden&quot; &quot;Gordon Hayward&quot; &quot;Kemba Walker&quot; &quot;Trevor Ariza&quot; ## [5] &quot;Khris Middleton&quot; &quot;Kyle Lowry&quot; &quot;Marcus Morris&quot; &quot;Andrew Wiggins&quot; ## [9] &quot;Paul George&quot; &quot;Gi Antetokounmpo&quot; 6.10.5 欄位值篩選 除了排序取值外，也可用欄位條件搜尋，舉例來說，可以取出所有波士頓賽爾迪克隊的選手資料，使用subset()函數 subset(NBA1516,Team==&quot;BOS&quot;) ## League Name Team Position GamesPlayed TotalMinutesPlayed ## 60 NBA Avery Bradley BOS PG 76 2536 ## 89 NBA Coty Clarke BOS &lt;NA&gt; 4 8 ## 102 NBA Jae Crowder BOS SF 73 2310 ## 213 NBA R.j. Hunter BOS SG 36 319 ## 228 NBA Jonas Jerebko BOS PF 78 1178 ## 229 NBA Amir Johnson BOS PF 79 1798 ## 300 NBA Jordan Mickey BOS PF 16 59 ## 340 NBA Kelly Olynyk BOS C 69 1396 ## 382 NBA Terry Rozier BOS PG 39 310 ## 400 NBA Marcus Smart BOS PG 61 1666 ## 416 NBA Jared Sullinger BOS PF 81 1917 ## 422 NBA Isaiah Thomas BOS PG 82 2647 ## 433 NBA Evan Turner BOS SG 81 2270 ## 471 NBA James Young BOS SG 29 200 ## 476 NBA Tyler Zeller BOS C 60 714 ## FieldGoalsMade FieldGoalsAttempted ThreesMade ThreesAttempted ## 60 456 1018 147 406 ## 89 2 4 2 2 ## 102 359 812 122 363 ## 213 36 98 19 63 ## 228 118 286 43 108 ## 229 250 427 10 43 ## 300 8 22 0 0 ## 340 253 556 85 210 ## 382 29 106 6 27 ## 400 184 529 61 241 ## 416 351 807 29 104 ## 422 591 1382 167 465 ## 433 343 753 20 83 ## 471 11 36 6 26 ## 476 138 290 0 0 ## FreeThrowsMade FreeThrowsAttempted OffensiveRebounds TotalRebounds Assists ## 60 96 123 48 220 158 ## 89 0 0 0 1 0 ## 102 196 239 70 373 135 ## 213 6 7 2 37 13 ## 228 61 78 77 288 62 ## 229 69 121 178 505 137 ## 300 5 10 6 13 1 ## 340 96 128 72 281 105 ## 382 8 10 24 63 37 ## 400 129 166 76 255 186 ## 416 103 161 194 673 187 ## 422 474 544 46 243 509 ## 433 148 179 50 397 359 ## 471 1 4 4 26 9 ## 476 88 108 62 178 29 ## Steals Turnovers Blocks PersonalFouls Disqualifications TotalPoints ## 60 117 109 19 164 2 1155 ## 89 0 1 0 0 0 6 ## 102 126 83 35 198 4 1036 ## 213 14 11 4 29 0 97 ## 228 20 52 24 137 2 340 ## 229 52 94 83 214 1 579 ## 300 0 1 11 5 0 21 ## 340 52 74 33 163 3 687 ## 382 6 19 1 23 0 72 ## 400 91 80 18 183 1 558 ## 416 75 102 47 209 2 834 ## 422 91 220 9 167 1 1823 ## 433 80 169 28 139 0 854 ## 471 6 5 1 17 0 29 ## 476 10 46 22 97 1 364 ## Technicals Ejections FlagrantFouls GamesStarted ## 60 0 0 0 72 ## 89 0 0 0 0 ## 102 3 0 0 73 ## 213 0 0 0 0 ## 228 1 0 0 0 ## 229 0 0 0 76 ## 300 0 0 0 0 ## 340 1 0 0 8 ## 382 0 0 0 0 ## 400 2 0 0 10 ## 416 2 0 0 73 ## 422 9 0 0 79 ## 433 2 0 0 12 ## 471 0 0 0 0 ## 476 0 0 0 3 6.10.6 字串條件搜尋後篩選 當然也可以結合字串搜尋函數grepl()，將所有名字裡有“James”的選手資料取出 NBA1516[grepl(&quot;James&quot;,NBA1516$Name),] ## League Name Team Position GamesPlayed TotalMinutesPlayed ## 15 NBA James Anderson SAC SG 51 721 ## 132 NBA James Ennis NOR SF 22 329 ## 178 NBA James Harden HOU SG 82 3121 ## 222 NBA Lebron James CLE SF 76 2710 ## 231 NBA James Johnson TOR PF 57 924 ## 239 NBA James Jones CLE SG 48 466 ## 286 NBA James Mcadoo GSW SG 41 265 ## 471 NBA James Young BOS SG 29 200 ## FieldGoalsMade FieldGoalsAttempted ThreesMade ThreesAttempted ## 15 67 178 23 86 ## 132 54 113 26 58 ## 178 710 1617 236 656 ## 222 737 1416 87 282 ## 231 114 240 20 66 ## 239 59 143 41 104 ## 286 45 84 1 2 ## 471 11 36 6 26 ## FreeThrowsMade FreeThrowsAttempted OffensiveRebounds TotalRebounds Assists ## 15 22 29 13 86 41 ## 132 25 34 21 42 21 ## 178 720 837 63 502 612 ## 222 359 491 111 565 512 ## 231 39 68 28 126 67 ## 239 21 26 8 50 14 ## 286 26 49 30 58 17 ## 471 1 4 4 26 9 ## Steals Turnovers Blocks PersonalFouls Disqualifications TotalPoints ## 15 21 42 14 54 0 179 ## 132 16 19 5 28 1 159 ## 178 138 374 51 229 1 2376 ## 222 104 249 49 143 0 1920 ## 231 29 54 33 84 0 287 ## 239 11 13 10 50 0 180 ## 286 10 16 8 39 0 117 ## 471 6 5 1 17 0 29 ## Technicals Ejections FlagrantFouls GamesStarted ## 15 0 0 0 15 ## 132 0 0 0 5 ## 178 2 0 0 82 ## 222 3 0 0 76 ## 231 0 0 0 32 ## 239 1 0 0 0 ## 286 0 0 0 1 ## 471 0 0 0 0 References "],
["eda.html", "7 探索式資料分析 7.1 什麼是探索式資料分析 7.2 data.table 7.3 dplyr", " 7 探索式資料分析 7.1 什麼是探索式資料分析 探索式資料分析 (Exploratory Data Analysis) 的主要精神是運用視覺化、基本的統計等工具，反覆的探索資料特性，獲取資料所包含的資訊、結構和特點，因為在進行複雜或嚴謹的分析之前，必須要對資料有更多認識，才能訂定對的資料分析方向。 探索式資料分析包括分析各變數間的關聯性，看是否有預料之外的有趣發現，或是觀察資料內容是否符合預期，若否，檢查資料是否有誤，最後檢查資料是否符合分析前的假設，由上述可知，探索式資料分析通常不需要嚴謹的假設和細節呈現，主要功能還是『觀察』資料的特性。在資料量大/雜的時候，探索式資料分析就非常重要，因為透過探索式資料分析，分析人員可以在複雜的統計計算與耗時的模型建立前，就先發現可能的錯誤，更重要的是，可以透過探索性分析來調整分析的方向，減少因分析方向錯誤所造成的時間浪費。 探索式資料分析分為: 圖形化Graphical 或 量化Quantitative 單變量Univariate 或 雙變量Bivariate 或 多變量Multivariate 圖形化的分析方式包括做圖與列表，量化的分析方式則是資料初步統計，本章節著重於量化的分析方式，圖形化的分析方式請參考Ch 8。 以單變量分析來說，量化的分析方式可包含 計算集中趨勢 (維基百科) 平均值 Mean mean() 中位數 Median median() 眾數 Mode，R無內建函數，可直接用table()找出現次數最多的資料 計算資料分散程度 最小值 Min min() 最大值 Max max() 範圍 Range range() 四分位差 Quartiles quantile() 變異數 Variance var() 標準差 Standard deviation sd() 以雙變量分析來說，分析方式可包括: 列聯表 Crosstabs table(), ftable(), prop.table() 共變數 Covariance cov() 相關性 Correlation cor() 量化分析方式的測量值大多可用R的內建函數完成計算，但是在探索式分析時，常常需要遇到資料分組的分析情形（如觀察男性和女性的血壓差異、A隊與B隊的三分球命中率差異、中鋒和後衛的助攻次數…等），若只用基本的內建函數計算，需要先完成資料分組或子集後，再作進一步的運算，相當耗時，為了使這類資料分組與分析的工作更容易被完成，本書在介紹探索式資料分析時會搭配介紹data.table(Dowle and Srinivasan 2019)和dplyr(Wickham, Francois, et al. 2020) packages，這兩個packages各有優點，可依自己喜好選用。 7.2 data.table data.table是data.frame資料框型別的延伸，如要使用必須安裝並載入data.table(Dowle and Srinivasan 2019) package install.packages(&quot;data.table&quot;) ##安裝 library(data.table) ##載入 使用data.table讀取大型資料的速度比使用資料框快上數倍，效能比較可參考Benchmarks : Grouping，讀取資料的函數為fread()，使用方法與一般檔案讀取方法(Ch ??)類似 fread(&quot;檔案名稱&quot;) 如果已經使用其他資料來源將檔案讀成資料框data.frame格式，可以使用data.table()函數將data.frame轉為data.table格式，以先前介紹過的NBA資料為例（Ch 6.10，需安裝與載入SportsAnalytics套件） library(SportsAnalytics) library(data.table) NBA1516&lt;-fetch_NBAPlayerStatistics(&quot;15-16&quot;) NBA1516DT&lt;-data.table(NBA1516) class(NBA1516DT) ## [1] &quot;data.table&quot; &quot;data.frame&quot; 可以發現轉換後的NBA1516DT資料型態為data.table以及data.frame，這是因為data.table是data.frame資料框型別的延伸，所以是data.table型態的資料，就一定會是data.frame型態。 data.table資料型態的特殊結構和語法設計，便於後續資料分析處理，基本語法結構如下： DT[i,j,by=] i 觀察值 (Row) 篩選邏輯 j 所需欄位 (Column) by 分組依據 各參數間需要以逗號,區隔，但若只需使用前方參數，後方的,可省略，如只需使用i和j兩個參數，可以寫成DT[i,j]。 各參數的使用方法分述如下： 7.2.1 i 觀察值篩選邏輯 第一個參數i是用來篩選觀察值，也就是針對列(Row)做子集。篩選方式與Ch 6.4雷同，可透過布林值的向量或是元素索引(index)向量指定篩選條件，透過觀察值的篩選，可保留需要的資料，進行後續分析。 以前述NBA球員資料為例，如需擷取球員姓名包含James字串的資料，可使用下列指令： NBA1516DT[grepl(&#39;James&#39;,Name)] League Name Team Position GamesPlayed TotalMinutesPlayed FieldGoalsMade FieldGoalsAttempted ThreesMade ThreesAttempted FreeThrowsMade FreeThrowsAttempted OffensiveRebounds TotalRebounds Assists Steals Turnovers Blocks PersonalFouls Disqualifications TotalPoints Technicals Ejections FlagrantFouls GamesStarted NBA James Anderson SAC SG 51 721 67 178 23 86 22 29 13 86 41 21 42 14 54 0 179 0 0 0 15 NBA James Ennis NOR SF 22 329 54 113 26 58 25 34 21 42 21 16 19 5 28 1 159 0 0 0 5 NBA James Harden HOU SG 82 3121 710 1617 236 656 720 837 63 502 612 138 374 51 229 1 2376 2 0 0 82 NBA Lebron James CLE SF 76 2710 737 1416 87 282 359 491 111 565 512 104 249 49 143 0 1920 3 0 0 76 NBA James Johnson TOR PF 57 924 114 240 20 66 39 68 28 126 67 29 54 33 84 0 287 0 0 0 32 NBA James Jones CLE SG 48 466 59 143 41 104 21 26 8 50 14 11 13 10 50 0 180 1 0 0 0 NBA James Mcadoo GSW SG 41 265 45 84 1 2 26 49 30 58 17 10 16 8 39 0 117 0 0 0 1 NBA James Young BOS SG 29 200 11 36 6 26 1 4 4 26 9 6 5 1 17 0 29 0 0 0 0 如需篩選所有中鋒，且姓名包含“A”字串的球員資料，可使用下列指令： NBA1516DT[grepl(&#39;A&#39;,Name)&amp;Position==&quot;C&quot;] League Name Team Position GamesPlayed TotalMinutesPlayed FieldGoalsMade FieldGoalsAttempted ThreesMade ThreesAttempted FreeThrowsMade FreeThrowsAttempted OffensiveRebounds TotalRebounds Assists Steals Turnovers Blocks PersonalFouls Disqualifications TotalPoints Technicals Ejections FlagrantFouls GamesStarted NBA Steven Adams OKL C 80 2019 261 426 0 0 114 196 218 531 61 42 84 89 223 2 636 2 0 0 80 NBA Alexis Ajinca NOR C 59 863 150 314 0 1 52 62 75 269 32 19 54 36 134 0 352 2 0 0 17 NBA Cole Aldrich LAC C 60 802 134 225 0 0 60 84 86 288 50 47 64 68 139 1 328 0 0 0 5 NBA Joel Anthony DET C 19 95 6 10 0 0 6 8 8 21 1 2 2 12 15 0 18 0 0 0 0 NBA Omer Asik NOR C 68 1181 104 196 0 0 61 112 119 413 26 21 60 23 124 0 269 0 0 0 64 NBA Andrea Bargnani BRO C 46 634 127 278 3 15 47 57 28 97 18 4 26 9 61 0 304 0 0 0 0 NBA Andrew Bogut GSW C 70 1452 175 279 1 1 24 50 121 491 162 32 83 113 221 4 375 0 0 0 66 NBA Andre Drummond DET C 81 2664 552 1061 2 6 208 586 395 1198 67 119 154 112 245 2 1314 7 0 0 81 NBA Al Jefferson CHA C 47 1096 245 505 0 0 72 111 57 301 70 30 34 41 117 1 562 0 0 0 18 NBA Alex Len PHO C 78 1820 264 623 1 7 174 239 178 594 97 38 145 62 230 3 703 1 0 0 46 NBA Anderson Varejao GSW C 53 494 53 124 0 1 32 50 37 141 35 16 22 10 70 0 138 1 0 0 0 NBA Alan Williams PHO C 10 67 10 24 0 0 9 14 14 38 5 4 6 5 15 0 29 0 0 0 0 如需篩選各隊出場數超過80場的球員資料，可使用下列指令： NBA1516DT[GamesPlayed&gt;80] League Name Team Position GamesPlayed TotalMinutesPlayed FieldGoalsMade FieldGoalsAttempted ThreesMade ThreesAttempted FreeThrowsMade FreeThrowsAttempted OffensiveRebounds TotalRebounds Assists Steals Turnovers Blocks PersonalFouls Disqualifications TotalPoints Technicals Ejections FlagrantFouls GamesStarted NBA Al-farouq Aminu POR SF 82 2342 299 719 126 349 115 156 98 498 138 72 120 53 171 0 839 3 0 0 82 NBA Trevor Ariza HOU SF 81 2860 357 858 185 497 126 161 67 366 188 161 113 26 177 0 1025 2 0 0 81 NBA Will Barton DEN SG 82 2355 426 984 112 324 216 268 60 477 204 71 139 39 147 0 1180 2 0 0 1 NBA Aron Baynes DET PF 81 1241 194 384 0 2 126 165 140 384 51 21 67 52 151 0 514 0 0 0 1 NBA Bismack Biyombo TOR PF 82 1810 156 288 0 1 142 226 182 655 29 19 71 133 225 2 454 3 0 0 22 NBA Corey Brewer HOU SG 82 1670 212 552 61 225 105 140 42 199 109 84 78 19 168 1 590 0 0 0 12 NBA Allen Crabbe POR SF 81 2111 312 678 112 284 98 113 27 216 99 63 64 16 192 2 834 0 0 0 8 NBA Ed Davis POR PF 81 1684 206 337 0 0 114 204 224 599 88 57 64 72 202 2 526 2 0 0 0 NBA Gorgui Dieng MIN C 82 2222 308 578 6 20 205 248 156 584 143 94 140 96 219 0 827 1 0 0 39 NBA Andre Drummond DET C 81 2664 552 1061 2 6 208 586 395 1198 67 119 154 112 245 2 1314 7 0 0 81 NBA Jared Dudley WAS SG 81 2098 233 487 100 239 72 98 54 286 170 75 80 18 190 1 638 1 0 0 41 NBA Monta Ellis IND PG 81 2733 436 1021 87 281 162 206 42 272 382 149 203 38 174 0 1121 1 0 0 81 NBA Randy Foye OKC SG 81 1640 168 481 75 250 61 74 24 156 160 39 86 29 131 0 472 0 0 0 8 NBA Langsto Galloway NYK PG 82 2032 231 588 77 224 86 114 43 288 207 77 61 22 177 2 625 0 0 0 7 NBA Paul George IND SF 81 2828 605 1448 210 565 454 528 79 563 329 152 265 29 230 1 1874 6 0 0 81 NBA Draymond Green GSW SF 81 2807 401 819 100 258 229 329 130 765 597 118 259 111 240 2 1131 11 0 0 81 NBA James Harden HOU SG 82 3121 710 1617 236 656 720 837 63 502 612 138 374 51 229 1 2376 2 0 0 82 NBA Roy Hibbert LAL C 81 1881 182 411 0 2 117 145 131 398 95 32 76 110 252 3 481 2 0 0 81 NBA Al Horford ATL PF 82 2638 529 1049 88 257 103 129 148 597 263 67 107 122 163 0 1249 1 0 0 82 NBA Joe Ingles UTA SF 81 1241 124 291 81 210 13 18 19 151 96 55 65 4 98 0 342 1 0 0 2 NBA Joe Johnson MIA SF 81 2703 377 859 120 313 118 142 49 292 318 61 160 4 146 0 992 1 0 0 81 NBA Frank Kaminsky CHA PF 81 1713 215 525 68 202 108 148 69 336 97 37 58 43 126 0 606 0 0 0 3 NBA Enes Kanter OKL C 82 1721 415 720 10 21 200 251 250 665 33 26 115 33 166 1 1040 2 0 0 1 NBA Zach Lavine MIN PG 82 2295 433 960 123 316 161 203 28 229 252 69 155 17 193 1 1150 0 0 0 33 NBA Robin Lopez NYK C 82 2213 357 662 0 1 128 161 268 602 114 16 133 129 182 2 842 3 0 0 82 NBA T.j. Mcconnell PHI PG 81 1609 218 464 31 89 26 41 43 250 367 95 140 10 114 0 493 0 0 0 17 NBA Doug Mcdermott CHI SF 81 1860 291 644 110 259 72 84 37 195 59 14 52 6 127 0 764 0 0 0 4 NBA Patty Mills SAN PG 81 1659 260 612 123 320 47 58 27 158 226 59 76 6 102 0 690 0 0 0 3 NBA Paul Millsap ATL PF 81 2640 501 1067 74 232 309 408 197 733 264 148 191 140 237 2 1385 4 0 0 81 NBA Shabazz Muhammad MIN SF 82 1678 317 681 44 152 185 242 100 267 52 24 70 7 94 0 863 0 0 0 0 NBA Raul Neto UTA PG 81 1501 180 418 64 162 52 70 17 120 173 62 109 2 122 1 476 0 0 0 53 NBA Mason Plumlee POR PF 82 2087 267 517 0 4 215 335 201 628 226 68 154 82 253 4 749 1 0 0 82 NBA Julius Randle LAL PF 81 2287 358 835 10 36 193 270 172 830 144 53 149 29 242 2 919 0 0 0 60 NBA Ramon Sessions WAS PG 82 1667 280 592 36 111 214 283 26 204 240 47 115 5 102 0 810 0 0 0 5 NBA Jared Sullinger BOS PF 81 1917 351 807 29 104 103 161 194 673 187 75 102 47 209 2 834 2 0 0 73 NBA Isaiah Thomas BOS PG 82 2647 591 1382 167 465 474 544 46 243 509 91 220 9 167 1 1823 9 0 0 79 NBA Tristan Thompson CLE C 82 2269 247 420 0 0 149 242 268 738 63 38 61 51 202 0 643 1 0 0 34 NBA Karl-antho Towns MIN C 82 2621 625 1152 30 88 223 275 226 854 161 58 183 138 245 1 1503 2 0 0 82 NBA P.j. Tucker PHO SF 82 2540 239 582 68 206 106 142 165 512 177 106 111 20 202 3 652 4 0 0 80 NBA Evan Turner BOS SG 81 2270 343 753 20 83 148 179 50 397 359 80 169 28 139 0 854 2 0 0 12 NBA Kemba Walker CHA PG 81 2885 568 1332 182 490 371 438 56 358 421 127 171 39 111 0 1689 5 0 0 81 NBA Andrew Wiggins MIN SF 81 2844 594 1294 57 190 430 565 107 294 164 78 182 46 165 1 1675 1 0 0 81 NBA Marvin Williams CHA PF 81 2339 338 747 152 379 120 144 127 520 110 58 62 77 133 1 948 0 0 0 81 7.2.2 j 欄位選擇運算 第二個參數j是用來決定輸出欄位，輸出的欄位可以是原始欄位，也可以是計算後的欄位，以計算所有球員的平均出場數為例： NBA1516DT[,mean(GamesPlayed)] ##因沒有篩選需求，,前方留空 ## [1] 55 也可以一次計算多個數值，如同時計算平均出場數、平均犯規次數以及平均抄截次數，此時第二個欄位j需要使用.()包起來 NBA1516DT[,.(mean(GamesPlayed),mean(PersonalFouls),mean(Steals))] ##因沒有篩選需求，,前方留空 ## V1 V2 V3 ## 1: 55 105 41 由上述輸出可以發現輸出的數字自動被加上欄位名稱V1, V2, V3，可能會造成數據判別錯誤，所以在計算新欄位時，可以在新欄位定義的前方加上欄位名稱=，同時替欄位取名字 NBA1516DT[,.(GamesPlayedMean=mean(GamesPlayed), PersonalFoulsMean=mean(PersonalFouls), StealsMean=mean(Steals))] ## GamesPlayedMean PersonalFoulsMean StealsMean ## 1: 55 105 41 除了計算平均值以外，當然可以帶入其他函式做各式各樣的運算 NBA1516DT[,.(GamesPlayedMax=max(GamesPlayed), #最大值 ThreesMadeMin=min(ThreesMade), #最小值 FieldGoalsMadeSD=sd(FieldGoalsMade))] #標準差 ## GamesPlayedMax ThreesMadeMin FieldGoalsMadeSD ## 1: 82 0 166 若配合第一個參數一起使用，可以計算出所有出場數大於70的球員，平均投進幾顆三分球與兩分球 NBA1516DT[GamesPlayed&gt;70, .(ThreesMadeMean=mean(ThreesMade), FieldGoalsMadeMean=mean(FieldGoalsMade))] ## ThreesMadeMean FieldGoalsMadeMean ## 1: 76 335 7.2.3 by 分組依據 第三個參數by為分組計算的依據，舉例來說，我們可以計算NBA各隊的球員數與平均助攻數，球員個數的計算在data.table內可使用.N指令，平均使用mean()函數，此時只要在by=後方加上分組依據(各隊Team)，即可完成運算 NBA1516DT[,.(.N,AssistsMean=mean(Assists)), by=Team] ## Team N AssistsMean ## 1: SAC 15 134 ## 2: MEM 22 74 ## 3: OKL 14 126 ## 4: NYK 16 105 ## 5: NOR 21 87 ## 6: LAC 15 124 ## 7: SAN 16 130 ## 8: POR 15 116 ## 9: IND 15 125 ## 10: WAS 17 127 ## 11: DAL 15 124 ## 12: MIL 17 113 ## 13: DET 15 105 ## 14: ORL 15 128 ## 15: HOU 16 101 ## 16: LAL 15 99 ## 17: DEN 15 122 ## 18: CHI 15 121 ## 19: GSW 15 158 ## 20: BRO 16 100 ## 21: CHA 14 118 ## 22: ATL 15 142 ## 23: TOR 16 97 ## 24: MIN 14 129 ## 25: PHO 17 97 ## 26: UTA 17 94 ## 27: MIA 15 131 ## 28: BOS 15 128 ## 29: PHI 16 118 ## 30: CLE 16 117 ## 31: OKC 1 160 ## Team N AssistsMean .N在data.table內是保留字，用來計算個數 三個參數結合使用，可以輕鬆計算出NBA各隊的中鋒球員數和他們的平均三分球出手次數，指令如下： NBA1516DT[Position==&quot;C&quot;, .(.N,ThreesAttemptedMean=mean(ThreesAttempted)), by=Team] ## Team N ThreesAttemptedMean ## 1: OKL 3 7.00 ## 2: NOR 4 0.25 ## 3: LAC 2 0.50 ## 4: DET 2 3.00 ## 5: BRO 3 10.00 ## 6: LAL 3 0.67 ## 7: WAS 2 1.00 ## 8: GSW 4 16.00 ## 9: SAN 3 34.67 ## 10: HOU 2 3.50 ## 11: SAC 3 70.67 ## 12: PHO 3 2.67 ## 13: ORL 2 4.50 ## 14: MIN 3 36.00 ## 15: MEM 2 1.50 ## 16: UTA 3 1.33 ## 17: IND 2 0.50 ## 18: CHA 1 0.00 ## 19: DEN 2 43.50 ## 20: POR 2 116.00 ## 21: CLE 3 2.33 ## 22: NYK 1 1.00 ## 23: DAL 3 1.67 ## 24: MIL 2 0.50 ## 25: CHI 1 1.00 ## 26: PHI 2 4.00 ## 27: TOR 3 6.00 ## 28: BOS 2 105.00 ## 29: ATL 1 0.00 ## 30: MIA 1 0.00 ## Team N ThreesAttemptedMean 7.2.4 參考文件與資源 data.table還有很多好用的功能，有興趣的話可以參考下列資料 官網 指令全集The data.table R package cheat sheet A data.table R tutorial by DataCamp DataCamp互動式教學課程 7.3 dplyr dplyr(Wickham, Francois, et al. 2020) package是Hadley Wickham開發的資料處理分析套件，如要使用必須安裝並載入dplyr package install.packages(&quot;dplyr&quot;) ##安裝 library(dplyr) ##載入 dplyr使用以下函數分析整理資料： select(): 選要分析的欄位，欄位子集 (Column) filter(): 選要分析的觀察值，觀察值子集 (Row) mutate(): 增加新欄位 summarise(): 計算統計值 group_by(): 分組依據 arrange(): 觀察值排序 rename(): 欄位重新命名 %&gt;%: the “pipe” operator 連結上數函式，將所有函式計算串在一起執行 以上述NBA資料為例，各函數功能分述如下： 首先先讀入資料 library(SportsAnalytics) NBA1516&lt;-fetch_NBAPlayerStatistics(&quot;15-16&quot;) 7.3.1 select() 使用select()函式可選要分析的欄位，也就是針對欄位 (Column)做子集，函式使用方式為select(資料名稱,欄位條件1,欄位條件2,...)，其中條件1與條件2是使用或的連結概念。另外dplyr提供幾個方便篩選名稱的函式： starts_with() ends_with() contains() matches() num_range() one_of() everything() 詳細說明可在R執行視窗中輸入?select_helpers查看。 舉例來說，我們想要篩選欄位名稱為Name、ThreesMade、ThreesAttempted、FieldGoalsMade與FieldGoalsAttempted的五個欄位，指令範例如下 ##等同於 ##NBA1516[,c(&quot;Name&quot;,&quot;ThreesMade&quot;,&quot;ThreesAttempted&quot;,&quot;FieldGoalsMade&quot;,&quot;FieldGoalsAttempted&quot;)] select1&lt;-select(NBA1516,Name,starts_with(&quot;Threes&quot;),starts_with(&quot;FieldGoals&quot;)) head(select1) ## Name ThreesMade ThreesAttempted FieldGoalsMade FieldGoalsAttempted ## 1 Quincy Acy 19 49 119 214 ## 2 Jordan Adams 0 1 2 6 ## 3 Steven Adams 0 0 261 426 ## 4 Arron Afflalo 91 238 354 799 ## 5 Alexis Ajinca 0 1 150 314 ## 6 Cole Aldrich 0 0 134 225 若想篩選欄位Name到欄位FreeThrowsAttempted間的所有欄位，可用:串連欄位名稱 ##等同於NBA1516[,2:12] select2&lt;-select(NBA1516,Name:FreeThrowsAttempted) head(select2) ## Name Team Position GamesPlayed TotalMinutesPlayed FieldGoalsMade ## 1 Quincy Acy SAC SF 59 877 119 ## 2 Jordan Adams MEM SG 2 15 2 ## 3 Steven Adams OKL C 80 2019 261 ## 4 Arron Afflalo NYK SG 71 2359 354 ## 5 Alexis Ajinca NOR C 59 863 150 ## 6 Cole Aldrich LAC C 60 802 134 ## FieldGoalsAttempted ThreesMade ThreesAttempted FreeThrowsMade ## 1 214 19 49 50 ## 2 6 0 1 3 ## 3 426 0 0 114 ## 4 799 91 238 110 ## 5 314 0 1 52 ## 6 225 0 0 60 ## FreeThrowsAttempted ## 1 68 ## 2 5 ## 3 196 ## 4 131 ## 5 62 ## 6 84 ##等同於NBA1516[,c(2:4,6:12)] select3&lt;-select(NBA1516,Name:FreeThrowsAttempted,-GamesPlayed) head(select3) ## Name Team Position TotalMinutesPlayed FieldGoalsMade ## 1 Quincy Acy SAC SF 877 119 ## 2 Jordan Adams MEM SG 15 2 ## 3 Steven Adams OKL C 2019 261 ## 4 Arron Afflalo NYK SG 2359 354 ## 5 Alexis Ajinca NOR C 863 150 ## 6 Cole Aldrich LAC C 802 134 ## FieldGoalsAttempted ThreesMade ThreesAttempted FreeThrowsMade ## 1 214 19 49 50 ## 2 6 0 1 3 ## 3 426 0 0 114 ## 4 799 91 238 110 ## 5 314 0 1 52 ## 6 225 0 0 60 ## FreeThrowsAttempted ## 1 68 ## 2 5 ## 3 196 ## 4 131 ## 5 62 ## 6 84 7.3.2 filter() 使用filter()函式可選要分析的觀察值，也就是針對列 (Row)做子集，使用方法為filter(資料名稱,篩選條件)，舉例來說，如果想要看出場分鐘數超過2850分鐘的球員資料，可用輸入下列指令 ##等同於 NBA1516[NBA1516$TotalMinutesPlayed&gt;2850,] filter1&lt;-filter(NBA1516,TotalMinutesPlayed&gt;2850) filter1 ## League Name Team Position GamesPlayed TotalMinutesPlayed ## 1 NBA Trevor Ariza HOU SF 81 2860 ## 2 NBA James Harden HOU SG 82 3121 ## 3 NBA Gordon Hayward UTA SG 80 2889 ## 4 NBA Kyle Lowry TOR PG 77 2853 ## 5 NBA Khris Middleton MIL SF 79 2855 ## 6 NBA Marcus Morris DET SF 80 2852 ## 7 NBA Kemba Walker CHA PG 81 2885 ## FieldGoalsMade FieldGoalsAttempted ThreesMade ThreesAttempted FreeThrowsMade ## 1 357 858 185 497 126 ## 2 710 1617 236 656 720 ## 3 521 1202 143 410 393 ## 4 512 1198 212 546 398 ## 5 507 1144 143 362 277 ## 6 410 945 108 297 203 ## 7 568 1332 182 490 371 ## FreeThrowsAttempted OffensiveRebounds TotalRebounds Assists Steals Turnovers ## 1 161 67 366 188 161 113 ## 2 837 63 502 612 138 374 ## 3 477 61 397 296 95 202 ## 4 491 55 365 494 158 225 ## 5 312 45 301 331 131 180 ## 6 271 91 404 201 67 140 ## 7 438 56 358 421 127 171 ## Blocks PersonalFouls Disqualifications TotalPoints Technicals Ejections ## 1 26 177 0 1025 2 0 ## 2 51 229 1 2376 2 0 ## 3 27 183 0 1578 0 0 ## 4 34 211 1 1634 9 0 ## 5 19 204 1 1434 5 0 ## 6 23 170 1 1131 11 0 ## 7 39 111 0 1689 5 0 ## FlagrantFouls GamesStarted ## 1 0 81 ## 2 0 82 ## 3 0 80 ## 4 0 77 ## 5 0 79 ## 6 0 80 ## 7 0 81 也可選擇隊伍名稱為“BOS”或“SAN”的球員資料 ##等同於 NBA1516[NBA1516$Team %in% c(&quot;BOS&quot;,&quot;SAN&quot;),] filter2&lt;-filter(NBA1516,Team %in% c(&quot;BOS&quot;,&quot;SAN&quot;)) head(filter2) ## League Name Team Position GamesPlayed TotalMinutesPlayed ## 1 NBA Lamarcu Aldridge SAN PF 74 2260 ## 2 NBA Kyle Anderson SAN SF 78 1247 ## 3 NBA Matt Bonner SAN C 30 210 ## 4 NBA Avery Bradley BOS PG 76 2536 ## 5 NBA Rasual Butler SAN SF 46 432 ## 6 NBA Coty Clarke BOS &lt;NA&gt; 4 8 ## FieldGoalsMade FieldGoalsAttempted ThreesMade ThreesAttempted FreeThrowsMade ## 1 536 1045 0 16 259 ## 2 138 296 12 37 62 ## 3 29 58 15 35 3 ## 4 456 1018 147 406 96 ## 5 49 105 15 49 11 ## 6 2 4 2 2 0 ## FreeThrowsAttempted OffensiveRebounds TotalRebounds Assists Steals Turnovers ## 1 302 175 631 110 38 99 ## 2 83 25 245 123 60 59 ## 3 4 3 27 9 6 3 ## 4 123 48 220 158 117 109 ## 5 16 3 56 24 13 8 ## 6 0 0 1 0 0 1 ## Blocks PersonalFouls Disqualifications TotalPoints Technicals Ejections ## 1 81 151 0 1331 0 0 ## 2 29 97 0 350 0 0 ## 3 1 16 0 76 0 0 ## 4 19 164 2 1155 0 0 ## 5 23 11 0 124 0 0 ## 6 0 0 0 6 0 0 ## FlagrantFouls GamesStarted ## 1 0 74 ## 2 0 11 ## 3 0 2 ## 4 0 72 ## 5 0 0 ## 6 0 0 在filter()函式中可直接做變數計算後再篩選 ##等同於 filter3&lt;-filter(NBA1516,FieldGoalsMade/FieldGoalsAttempted&gt;0.7) filter3 ## League Name Team Position GamesPlayed TotalMinutesPlayed ## 1 NBA Th Antetokounmpo NYK SF 3 7 ## 2 NBA Rakeem Christmas IND PF 1 6 ## 3 NBA Deandre Jordan LAC C 77 2600 ## FieldGoalsMade FieldGoalsAttempted ThreesMade ThreesAttempted FreeThrowsMade ## 1 3 4 0 1 0 ## 2 2 2 0 0 0 ## 3 357 507 0 1 266 ## FreeThrowsAttempted OffensiveRebounds TotalRebounds Assists Steals Turnovers ## 1 0 0 1 0 0 0 ## 2 0 1 1 0 0 0 ## 3 619 267 1059 90 52 107 ## Blocks PersonalFouls Disqualifications TotalPoints Technicals Ejections ## 1 0 2 0 6 0 0 ## 2 0 1 0 4 0 0 ## 3 176 207 1 980 10 0 ## FlagrantFouls GamesStarted ## 1 0 0 ## 2 0 0 ## 3 0 77 也可使用 &amp; 和 |等符號串連邏輯 ##等同於 filter4&lt;-filter(NBA1516,FieldGoalsMade/FieldGoalsAttempted&gt;0.7 &amp; GamesPlayed&gt;30) filter4 ## League Name Team Position GamesPlayed TotalMinutesPlayed ## 1 NBA Deandre Jordan LAC C 77 2600 ## FieldGoalsMade FieldGoalsAttempted ThreesMade ThreesAttempted FreeThrowsMade ## 1 357 507 0 1 266 ## FreeThrowsAttempted OffensiveRebounds TotalRebounds Assists Steals Turnovers ## 1 619 267 1059 90 52 107 ## Blocks PersonalFouls Disqualifications TotalPoints Technicals Ejections ## 1 176 207 1 980 10 0 ## FlagrantFouls GamesStarted ## 1 0 77 7.3.3 mutate() 使用mutate()增加新欄位，如需新增新欄位FieldGoalsRate，欄位值為FieldGoalsMade/FieldGoalsAttempted，指令如下 mutate1&lt;-mutate(NBA1516,FieldGoalsRate=FieldGoalsMade/FieldGoalsAttempted) mutate1$FieldGoalsRate[1:10] ## [1] 0.56 0.33 0.61 0.44 0.48 0.60 0.51 0.50 0.52 0.46 7.3.4 summarise() summarise()函式用來計算統計值，像是球員個數、不重複的隊伍數以及不重複的守備位置數等 sum1&lt;-summarise(NBA1516, nPlayer=n(), nTeam=n_distinct(Team), nPosition=n_distinct(Position)) sum1 ## nPlayer nTeam nPosition ## 1 476 31 6 計算統計值的功能通常會與其他功能合併使用，像是與前述filter()功能 Ch 7.3.2合併使用，可計算出場分鐘數大於2500分鐘的球員個數、平均投進的兩分球數以及平均投出的兩分球數 filter1&lt;-filter(NBA1516,TotalMinutesPlayed&gt;2500) sum2&lt;-summarise(filter1, nPlayer=n(), meanFieldGoalsMade=mean(FieldGoalsMade), meanFieldGoalsAttempted=mean(FieldGoalsAttempted)) sum2 ## nPlayer meanFieldGoalsMade meanFieldGoalsAttempted ## 1 40 512 1121 上述分析序列（先篩選再總和），可直接用pipe符號%&gt;%將指令串連，減少暫存物件（filter1）的生成，主要概念是先篩選後計算 sum3&lt;-filter(NBA1516,TotalMinutesPlayed&gt;2500) %&gt;% summarise(nPlayer=n(),meanFieldGoalsMade=mean(FieldGoalsMade), meanFieldGoalsAttempted=mean(FieldGoalsAttempted)) sum3 ## nPlayer meanFieldGoalsMade meanFieldGoalsAttempted ## 1 40 512 1121 7.3.5 group_by() group_by()函數的功能為設定分組依據，通常會與summarise()函式Ch 7.3.4合併使用，例如計算各隊（以Team作為分組依據）的球員數、平均投進的兩分球數以及平均投出的兩分球數 group1&lt;-group_by(NBA1516,Team)%&gt;% summarise(nPlayer=n(),meanFieldGoalsMade=mean(FieldGoalsMade), meanFieldGoalsAttempted=mean(FieldGoalsAttempted)) ## `summarise()` ungrouping output (override with `.groups` argument) head(group1) ## # A tibble: 6 x 4 ## Team nPlayer meanFieldGoalsMade meanFieldGoalsAttempted ## &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ATL 15 215 471. ## 2 BOS 15 209. 475. ## 3 BRO 16 181. 396. ## 4 CHA 14 199. 451. ## 5 CHI 15 209. 475. ## 6 CLE 16 200. 433. 當然也可以設定多個分組依據，像是計算各隊各守備位置（以Team和Position作為分組依據）的球員數、平均投進的兩分球數以及平均投出的兩分球數 group2&lt;-group_by(NBA1516,Team,Position)%&gt;% summarise(nPlayer=n(),meanFieldGoalsMade=mean(FieldGoalsMade), meanFieldGoalsAttempted=mean(FieldGoalsAttempted)) ## `summarise()` regrouping output by &#39;Team&#39; (override with `.groups` argument) head(group2) ## # A tibble: 6 x 5 ## # Groups: Team [2] ## Team Position nPlayer meanFieldGoalsMade meanFieldGoalsAttempted ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 ATL C 1 11 19 ## 2 ATL PF 6 247. 516. ## 3 ATL PG 2 382. 884 ## 4 ATL SG 6 161. 364. ## 5 BOS C 2 196. 423 ## 6 BOS PF 4 182. 386. 7.3.6 arrange() 排序功能，預設為遞增排序 arrange1&lt;-arrange(NBA1516,TotalMinutesPlayed) head(arrange1) ## League Name Team Position GamesPlayed TotalMinutesPlayed ## 1 NBA J.j. O&#39;brien UTA SF 1 2 ## 2 NBA Rakeem Christmas IND PF 1 6 ## 3 NBA Th Antetokounmpo NYK SF 3 7 ## 4 NBA Sam Dekker HOU SF 3 7 ## 5 NBA Coty Clarke BOS &lt;NA&gt; 4 8 ## 6 NBA Jordan Adams MEM SG 2 15 ## FieldGoalsMade FieldGoalsAttempted ThreesMade ThreesAttempted FreeThrowsMade ## 1 0 1 0 0 0 ## 2 2 2 0 0 0 ## 3 3 4 0 1 0 ## 4 0 0 0 0 0 ## 5 2 4 2 2 0 ## 6 2 6 0 1 3 ## FreeThrowsAttempted OffensiveRebounds TotalRebounds Assists Steals Turnovers ## 1 0 0 0 0 0 0 ## 2 0 1 1 0 0 0 ## 3 0 0 1 0 0 0 ## 4 0 0 1 0 1 0 ## 5 0 0 1 0 0 1 ## 6 5 0 2 3 3 2 ## Blocks PersonalFouls Disqualifications TotalPoints Technicals Ejections ## 1 0 0 0 0 0 0 ## 2 0 1 0 4 0 0 ## 3 0 2 0 6 0 0 ## 4 0 0 0 0 0 0 ## 5 0 0 0 6 0 0 ## 6 0 2 0 7 0 0 ## FlagrantFouls GamesStarted ## 1 0 0 ## 2 0 0 ## 3 0 0 ## 4 0 0 ## 5 0 0 ## 6 0 0 使用desc()將要遞減排序的變數包起來，就可以遞減排序 arrange2&lt;-arrange(NBA1516,desc(TotalMinutesPlayed),desc(GamesPlayed)) head(arrange2) ## League Name Team Position GamesPlayed TotalMinutesPlayed ## 1 NBA James Harden HOU SG 82 3121 ## 2 NBA Gordon Hayward UTA SG 80 2889 ## 3 NBA Kemba Walker CHA PG 81 2885 ## 4 NBA Trevor Ariza HOU SF 81 2860 ## 5 NBA Khris Middleton MIL SF 79 2855 ## 6 NBA Kyle Lowry TOR PG 77 2853 ## FieldGoalsMade FieldGoalsAttempted ThreesMade ThreesAttempted FreeThrowsMade ## 1 710 1617 236 656 720 ## 2 521 1202 143 410 393 ## 3 568 1332 182 490 371 ## 4 357 858 185 497 126 ## 5 507 1144 143 362 277 ## 6 512 1198 212 546 398 ## FreeThrowsAttempted OffensiveRebounds TotalRebounds Assists Steals Turnovers ## 1 837 63 502 612 138 374 ## 2 477 61 397 296 95 202 ## 3 438 56 358 421 127 171 ## 4 161 67 366 188 161 113 ## 5 312 45 301 331 131 180 ## 6 491 55 365 494 158 225 ## Blocks PersonalFouls Disqualifications TotalPoints Technicals Ejections ## 1 51 229 1 2376 2 0 ## 2 27 183 0 1578 0 0 ## 3 39 111 0 1689 5 0 ## 4 26 177 0 1025 2 0 ## 5 19 204 1 1434 5 0 ## 6 34 211 1 1634 9 0 ## FlagrantFouls GamesStarted ## 1 0 82 ## 2 0 80 ## 3 0 81 ## 4 0 81 ## 5 0 79 ## 6 0 77 結合group_by()、summarise()、arrange()，可完成一連串的資料分析，例如計算各隊各守備位置（以Team和Position作為分組依據）的球員數、平均投進的兩分球數以及平均投出的兩分球數，並依平均投進的兩分球數由大到小排序 arrange3&lt;-group_by(NBA1516,Team,Position)%&gt;% summarise(nPlayer=n(),meanFieldGoalsMade=mean(FieldGoalsMade), meanFieldGoalsAttempted=mean(FieldGoalsAttempted)) %&gt;% arrange(desc(meanFieldGoalsMade)) ## `summarise()` regrouping output by &#39;Team&#39; (override with `.groups` argument) head(arrange3) ## # A tibble: 6 x 5 ## # Groups: Team [6] ## Team Position nPlayer meanFieldGoalsMade meanFieldGoalsAttempted ## &lt;fct&gt; &lt;fct&gt; &lt;int&gt; &lt;dbl&gt; &lt;dbl&gt; ## 1 GSW PG 2 504 988 ## 2 CLE SF 2 440 864 ## 3 ORL SG 1 425 969 ## 4 MIA C 1 412 681 ## 5 OKL PG 2 385 861 ## 6 ATL PG 2 382. 884 7.3.7 rename() 新名稱=舊名稱 rename1&lt;-rename(NBA1516,Po=Position) rename1[1:5,1:5] ## League Name Team Po GamesPlayed ## 1 NBA Quincy Acy SAC SF 59 ## 2 NBA Jordan Adams MEM SG 2 ## 3 NBA Steven Adams OKL C 80 ## 4 NBA Arron Afflalo NYK SG 71 ## 5 NBA Alexis Ajinca NOR C 59 7.3.8 參考文件與資源 Introduction to dplyr DataCamp互動式教學課程 Data Manipulation in R with dplyr References "],
["vis.html", "8 資料視覺化 8.1 資料視覺化的目的 8.2 ggplot2簡介 8.3 ggplot2+地圖 8.4 Taiwan的面量圖 8.5 Treemap 8.6 參考文件與資源", " 8 資料視覺化 8.1 資料視覺化的目的 延續Ch 7，探索式資料分析可分為圖形化Graphical 或 量化Quantitative分析，總括來說作圖的目的有: 了解資料的特性 尋找資料的模式(patterns) 建議資料分析與建模的策略 結果呈現與溝通 其中前三項屬於探索圖 (Exploratory graphs)，結果呈現與溝通屬於結果圖 (Final graphs)，探索圖屬探索式資料分析，目的是在『看』與『觀察』資料的樣子，所以探索圖有以下特性: 很快就可以做一張圖 探索過程中，可能可以做圖 主要目的是了解資料的樣子 不用做圖形格式調整美化 而在製作結果圖 (Final graphs)時，則須考慮以下事項: 比較，呈現差異 比較什麼？誰跟誰比較？ 呈現因果關係（causality）,機制（mechanism）,結果解釋（explanation）,系統化的結構（systematic structure） 因果模型？為什麼你想要做這樣的比較 呈現多變數（Multivariate）資料 多變數（Multivariate）：超過兩個變數就叫多變數 所有真實事件都是多變數的 將證據整合呈現 在同一個畫面呈現文字、數字、影像、圖表 盡量用圖形呈現資料 將圖表做適當的標記與說明，包括xy軸名稱、單位、資料來源等 資料圖表必須可以呈現你想說的故事 內容才是最重要的 資料不好，分析不好，圖表再美也沒有用 在R中，有三個常用的畫圖套件，包括基本功能(Base)、lattice以及ggplot2，由於各套件繪圖邏輯不同，本書只介紹最推薦的ggplot2套件的使用方式。 8.2 ggplot2簡介 ggplot2 (Wickham, Chang, et al. 2020)的開發靈感來自於Dr. Leland Wilkinson的Grammar of Graphics “In brief, the grammar tells us that a statistical graphic is a mapping from data to aesthetic attributes (colour, shape, size) of geometric objects (points, lines, bars). The plot may also contain statistical transformations of the data and is drawn on a specific coordinate system” -from ggplot2 book ggplot2 Package是由Hadley Wickham開發，是第三個R的畫圖Package。自發表以來一直是最熱門的R packages之一，目前還在持續發展更新中，對原始碼有興趣的人可以到GitHub看一下最新動態。 簡單來說，做圖的文法包括兩個最主要元素： Aesthetic attributes：包括顏色、形狀、點的大小與線的粗細等 Geometric objects：包括點、線、盒狀圖、直條圖等 其他元素包括： Facets：提供在同一張圖內做多個子圖的方法，只要使用Faceting功能設定子圖分類的依據參數即可 Stats：將資料做統計轉換 Scales：修改點線的顏色、形狀、xy軸的範圍等 在開始學ggplot2的核心功能之前，qplot()是ggplot2 Package提供最基本的畫圖方法，跟基本的plot() function很接近，提供一個簡單入門的方法。 8.2.1 qplot() qplot()為ggplot2 “Hello, world!”，簡單使用qplot(x軸名稱,y軸名稱,data=使用資料)就可畫散佈圖 library(SportsAnalytics) NBA1516&lt;-fetch_NBAPlayerStatistics(&quot;15-16&quot;) ## 讀入資料 library(ggplot2) #記得將ggplot2 package讀入，如果沒安奘記得先安裝 qplot(FieldGoalsAttempted, TotalPoints, data = NBA1516) 針對做圖的文法的第一個主要元素Aesthetics（包括顏色、形狀、點的大小與線的粗細等），可透過增加指令做修改，如加上color=Position，表示用守備位置Position著色 qplot(FieldGoalsAttempted, TotalPoints, data = NBA1516,color=Position) 針對做圖的文法的第二個主要元素Geometric（包括點、線、盒狀圖、直條圖等），也可透過增加指令修改，如使用geom = c(\"point\", \"smooth\") 在圖上加點與漸進線 qplot(FieldGoalsAttempted, TotalPoints, data = NBA1516, geom = c(&quot;point&quot;, &quot;smooth&quot;)) ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 如果輸入的變量並非雙變量，而是單變量時，預設圖形會從散佈圖變為Histograms直方圖 #畫TotalPoints的直方圖/ fill = Position 並用守備位置Position著色 qplot(TotalPoints, data = NBA1516, fill = Position) 作圖的Facets元素可提供在同一張圖內做多個子圖的方法，只要使用facets =來設定子圖分類的依據參數即可，以下圖為例，輸入的變量是雙變量，所以預設圖形為散佈圖，而設定子圖的語法為直向分類~橫向分類，直向分類意指以增加列（Row）的方式畫子圖，橫向分類意指以增加行（Column）的方式畫子圖，通常只會設定單一方向，如果選擇的是直向，橫向分類部分可用.表示，範例如下： #facets = . ~ Position 用守備位置Position分群畫圖(橫向) qplot(FieldGoalsAttempted, TotalPoints, data = NBA1516, facets = . ~ Position) #facets = . ~ Position 用守備位置Position分群畫圖(直向) qplot(FieldGoalsAttempted, TotalPoints, data = NBA1516, facets = Position ~ .) ggplot2套件會自動幫使用者選擇顏色與圖形各項參數，但使用者也可依需求微調，如直方圖的分組間隔，可透過binwidth參數設定 #facets = . ~ Position 用守備位置Position分群畫圖(直向) ##binwidth = 2 每2分一組 qplot(TotalPoints, data = NBA1516, facets = Position ~ ., binwidth = 2) #facets = . ~ Position 用守備位置Position分群畫圖(直向) ##binwidth = 100 每100分一組 qplot(TotalPoints, data = NBA1516, facets = Position ~ ., binwidth = 100) 總括來說qplot()提供快速方便的畫圖功能，並且保留部分參數設定的彈性，但若需要調整更多參數，仍須使用完整的ggplot()函式。 8.2.2 ggplot() 使用ggplot2作圖有以下步驟： 準備好資料。當然要有資料才能畫圖 設定Aesthetic attributes。使用aes(x, y, ...)指定 指定Geometric objects。常用的包括geom_point()、geom_line()、geom_histogram()、geom_polygon()、geom_errorbar() library(ggplot2) ##須先安裝 install.packages(&quot;ggplot2&quot;) 首先先產生教學用畫圖資料 df &lt;- data.frame(gp = factor(rep(letters[1:3], each = 10)),y = rnorm(30)) 設定兩個畫圖的重要元素Aesthetic attributes和Geometric objects ggplot(df, aes(x = gp, y = y)) +geom_point() 用geom_boxpolt()改畫盒狀圖 ggplot(df, aes(x = gp, y = y)) +geom_boxplot() 使用Faceting功能 df$z&lt;-df$y+rnorm(30) ggplot(df, aes(x = z, y = y)) +geom_point()+facet_grid(gp~.) 轉向 ggplot(df, aes(x = z, y = y)) +geom_point()+facet_grid(.~gp) 用geom_smooth()替xy散佈圖加上趨勢線 ggplot(df, aes(x = z, y = y)) +geom_point()+facet_grid(gp~.)+geom_smooth() ## `geom_smooth()` using method = &#39;loess&#39; and formula &#39;y ~ x&#39; 用geom_smooth()替xy散佈圖加上趨勢線，使用linear regresion ggplot(df, aes(x = z, y = y)) +geom_point()+facet_grid(gp~.)+geom_smooth(method=&#39;lm&#39;) ## `geom_smooth()` using formula &#39;y ~ x&#39; 改用geom_line()畫線 ggplot(df, aes(x = z, y = y)) +geom_line()+facet_grid(gp~.) 改用顏色分組，使用aes(color='group name') ggplot(df, aes(x = z, y = y, color=gp)) +geom_line() 畫圖前需要注意的幾個小地方： 提供資料時，把資料修改為想要在圖片顯示的文字。從上面的範例可以發現，ggplot2會直接將資料分組（a/b/c）直接標在圖上，與其之後再來改圖，不如在資料處理時就將a/b/c改為有意義且可以直接使用的文字。 如果是離散性的資料，但卻又是數值時（像是1,2,3）可以用factor()轉換，ggplot會將factor視為離散資料。 除了基本的製圖外，ggplot2套件也提供完整的資料標示設定與其他參數設定功能，包括： 標籤 xlab(), ylab(), labs(x=,y=), ggtitle() 每一個geom_*()都有參數可設定 圖形樣式設定 theme()，可使用內建樣式 theme_gray(): 灰背景，預設樣式 theme_bw(): 黑白樣式 使用其他樣式套件 ggthemes packages Website xkcd packages Website 在比較多組的平均值高低時，因為各組樣本數與資料分佈不同，平均數的誤差值也會不同，所以在資料視覺化時，建議加上誤差線(Error bar)，誤差線通常使用在bar chart和line chart，而誤差值的計算有下列三種選擇： Standard deviation (SD) 標準差：呈現資料本質時使用 Standard error (SE) 標準誤差：呈現預估平均值的可能誤差時使用 Confidence interval (CI) 信賴區間：呈現預估平均值的信心時使用 以空氣污染料為例，若想比較各月臭氧濃度差異，可以使用bar chart來呈現，在ggplot2中，如果要畫bar chart，需要將Geometric objects設定為geom_bar library(datasets) library(data.table) airquality$Month&lt;-as.factor(airquality$Month) #將Month轉為因子變項 airquality.mean&lt;-data.table(airquality)[,.(OzoneMean=mean(Ozone,na.rm = T)),by=Month] #計算每月Ozone平均 ggplot()+geom_bar(data=airquality.mean,aes(x=Month,y=OzoneMean), stat = &quot;identity&quot;) #stat = &quot;identity&quot; 直接畫數字 在ggplot2套件中，只要加上geom_errorbar()函式，設定資料高低值，就能在原圖中加上誤差線 library(datasets) library(data.table) airquality$Month&lt;-as.factor(airquality$Month) #將Month轉為因子變項 airquality.stat&lt;-data.table(airquality)[,.(OzoneMean=mean(Ozone,na.rm = T),OzoneSD=sd(Ozone,na.rm = T)),by=Month] #計算每月Ozone平均與標準差 ggplot(data=airquality.stat)+ #資料airquality.eb geom_bar(aes(x=Month,y=OzoneMean),stat = &quot;identity&quot;)+ geom_errorbar( #ymin低點, ymax高點 aes(x=Month,ymin=OzoneMean-OzoneSD,ymax=OzoneMean+OzoneSD), width=.1) 8.3 ggplot2+地圖 8.3.1 Choropleth map面量圖 Choropleth map面量圖是指把統計資料用顏色畫在對應的地圖上的一種資料視覺化方式，在R中可以使用choroplethr(Lamstein 2018) package來畫面量圖， choroplethr package是一個基於ggplot2 package的面量圖做圖工具，使用前需要先安裝，建議同時安裝choroplethrMaps package install.packages(c(&quot;choroplethr&quot;,&quot;choroplethrMaps&quot;)) ##第一次使用前先安裝 library(choroplethr) choroplethr(Lamstein 2018) package內建美國各州地圖與人口學資料，所以可以輕鬆使用state_choropleth()函式畫出美國各州人口分布 data(df_pop_state) #記載各州人口數的資料 state_choropleth(df_pop_state) #把各州人口畫在地圖上 若將reference_map設定為= TRUE，可在面量圖的背景加上google地圖，因google地圖需要使用API key，因此須先使用ggmap套件的register_google(key = \"your key\")，帶入google金鑰設定授權金鑰。以下金鑰為示範金鑰，目前已失效，請自行至Google Cloud Platform，點選API及服務申請Maps Static API後，複製API key。 [2020/05/25更新]：似乎需在Google Cloud Platform 綁定服務使用付款信用卡才可以順利經由ggmap套件取得圖層。 data(continental_us_states) library(ggmap) register_google(key = &quot;AIzaSyBD_nXDjGMYcJO9e_3SI_h3YZwhx0if680&quot;) #demo key state_choropleth(df_pop_state,reference_map = TRUE, zoom= continental_us_states) #把各州人口畫在地圖上 除了美國地圖外，使用choroplethr package搭配WDI: World Development Indicators 的世界人口分布資料，可以針對世界人口分佈做面量圖。 世界人口資料的代碼為SP.POP.TOTL，代碼查詢可見World Development Indicators 由於需要使用WDI的資料，所以需要安裝與載入WDI(Arel-Bundock 2020) package install.packages(&quot;WDI&quot;) ##第一次使用前先安裝 library(WDI) choroplethr_wdi(code=&quot;SP.POP.TOTL&quot;, year=2016, title=&quot;2016 Population&quot;, num_colors=1) 除了人口資料外，WDI也有世界平均壽命資料，平均壽命的代碼為SP.DYN.LE00.IN，代碼查詢可見World Development Indicators choroplethr_wdi(code=&quot;SP.DYN.LE00.IN&quot;, year=2016, title=&quot;2016 Life Expectancy&quot;) 如果只需亞洲太平洋人口分布，可使用zoom參數設定想畫的國家，國家的名稱設定必須要和country.regions資料完全吻合 choroplethr_wdi(code=&quot;SP.POP.TOTL&quot;, year=2015, title=&quot;2015 Life Expectancy&quot;, zoom=c(&#39;taiwan&#39;,&#39;japan&#39;,&#39;south korea&#39;,&#39;philippines&#39;)) 8.3.2 ggmap() ggmap(Kahle, Wickham, and Jackson 2020) package是一個可以把google map載入並作圖的套件，一樣是基於ggplot2套件開發的。 依照往例，第一次使用前需要安裝 install.packages(&quot;ggmap&quot;, type = &quot;source&quot;) ##第一次使用前先安裝 載入ggmap(Kahle, Wickham, and Jackson 2020) package後，可以使用get_googlemap()函式取得google map圖層，並用ggmap()函式將取得的圖層畫出來，使用google map的資源時，必須先使用register_google(key = “your key”)帶入google金鑰。 投影片金鑰已失效，請自行至Google Cloud Platform，點選API及服務申請Maps Static API後，複製API key。 [2020/05/25更新]：似乎需在Google Cloud Platform 綁定服務使用付款信用卡才可以順利經由ggmap套件取得圖層。 get_googlemap()函式需要設定的參數如下： center 中心點經緯度座標 zoom 放大倍率 language 地圖語言 library(ggmap) register_google(key = &quot;AIzaSyBD_nXDjGMYcJO9e_3SI_h3YZwhx0if680&quot;)#demo key twmap &lt;- get_googlemap(center = c(lon=120.58,lat=23.58), zoom = 7, language = &quot;zh-TW&quot;) ggmap(twmap) 只要資料有經緯度等資訊，就可以使用ggmap package與各式資料結合呈現，以台北市水質地圖開放資料為例，首先先將資料載入處理（參考Ch ??）。台北市水質資料的Open data API網址是http://data.taipei/opendata/datalist/apiAccess?scope=resourceAquire&amp;rid=190796c8-7c56-42e0-8068-39242b8ec927 ##資料載入 library(jsonlite) library(RCurl) WaterData&lt;-fromJSON(getURL(&quot;http://data.taipei/opendata/datalist/apiAccess?scope=resourceAquire&amp;rid=190796c8-7c56-42e0-8068-39242b8ec927&quot;)) WaterDataFrame&lt;-WaterData$result$results WaterDataFrame$longitude&lt;-as.numeric(WaterDataFrame$longitude) WaterDataFrame$latitude&lt;-as.numeric(WaterDataFrame$latitude) WaterDataFrame$qua_cntu&lt;-as.numeric(WaterDataFrame$qua_cntu) ##結合ggmap library(ggmap) TaipeiMap &lt;- get_googlemap( center = c(lon=121.50,lat=25.06), zoom = 11, maptype = &#39;roadmap&#39;) TaipeiMapO &lt;- ggmap(TaipeiMap)+ geom_point(data=WaterDataClean, aes(x=longitude, y=latitude, color=qua_cntu),size=3.5)+ scale_color_continuous( low = &quot;yellow&quot;,high = &quot;red&quot;)+ guides(size=FALSE) TaipeiMapO ggmap套件提供多種地圖型態，使用者可透過設定maptype自行選擇適合的地圖樣式，樣式有： terrain terrain-background satellite roadmap hybrid (google maps) watercolor toner (stamen maps) 透過設定extent參數可將地圖輸出樣式改為滿版 library(ggmap) ggmap(TaipeiMap,extent = &#39;device&#39;) #extent = &#39;device&#39; 滿版 ###Density Map 除了面量圖外，密度圖Density Map也是常用來表示因地理位置不同的數值差異，以下是美國人口密度圖範例 上述範例使用 ggplot2 + ggmap 套件來畫人口密度圖，做圖的第一步是資料載入，包括取得美國各州中心座標資料以及美國各州人口資料 #取得美國各州中心座標資料 StateCenter&lt;-data.frame( region=tolower(state.name),lon=state.center$x,lat=state.center$y) head(StateCenter,1) ## region lon lat ## 1 alabama -87 33 #美國各州人口資料 StatePop&lt;-merge(df_pop_state,StateCenter,by=&quot;region&quot;) head(StatePop,1) ## region value lon lat ## 1 alabama 4777326 -87 33 第二個步驟是將人口數字轉換為資料列數，需要這樣轉換的原因是密度圖是用資料列數來決定畫圖的密度，而不是透過單一數值，所以需要在此步驟做轉換 #將人口數值，轉為點！重要！ PopPoint&lt;-NULL for(i in 1:nrow(StatePop)){ #每100萬人轉為1點 for(j in 1:(StatePop[i,&quot;value&quot;]/1000000)){ PopPoint&lt;-rbind(PopPoint,StatePop[i,]) } } head(PopPoint,3) ## region value lon lat ## 1 alabama 4777326 -87 33 ## 2 alabama 4777326 -87 33 ## 3 alabama 4777326 -87 33 第三個步驟是作圖 USMap &lt;- get_googlemap(center = c(lon=-99.582,lat=40.091), zoom = 4) densityMap&lt;-ggmap(USMap, extent = &quot;device&quot;) + geom_density2d(data = PopPoint, aes(x = lon, y = lat), size = 0.3) + stat_density2d(data = PopPoint, aes(x = lon, y = lat, fill = ..level.., alpha = ..level..), size = 0.01, bins = 16, geom = &quot;polygon&quot;) + scale_fill_gradient(low = &quot;green&quot;, high = &quot;red&quot;, guide = FALSE) + scale_alpha(range = c(0, 0.3), guide = FALSE) densityMap ###參考資料 - ggmap package source code - ggmap cheat sheet - ggmap doc 8.4 Taiwan的面量圖 因為畫台灣的面量圖尚無好的套件輔助，但因Open Data的關係，我們可以很容易地取得台灣鄉鎮市邊界的經緯度檔案，通常地圖/邊界經緯度檔案是用空間資料開放格式shapefile .shp儲存，透過政府資料開放平台可以下載台灣的地圖資料，資料集名稱為鄉鎮市區界線。使用shapefile與ggplot2畫圖的步驟如下： 取得空間資料檔案 使用rgdal, rgeos,maptools package處理地圖檔shapefile 使用ggplot2 &amp; RColorBrewer 畫圖 上述套件在第一次使用前需要安裝與載入 以上各步驟詳述如下： 1. 處理shapefile-1 需要rgdal, rgeos,maptools fortify: 將shapefile物件轉為data.frame library(ggplot2) #for fortify(), ggplot(), ggmap() head(tw_new$Town_ID) tw_new.df &lt;- fortify(tw_new, region = &quot;T_UID&quot;) #from ggplot2 package head(tw_new.df,10) long lat order hole piece id group 1 119.9170 26.17518 1 FALSE 1 1 1.1 2 119.9171 26.17517 2 FALSE 1 1 1.1 3 119.9171 26.17518 3 FALSE 1 1 1.1 4 119.9171 26.17518 4 FALSE 1 1 1.1 5 119.9171 26.17518 5 FALSE 1 1 1.1 6 119.9172 26.17518 6 FALSE 1 1 1.1 7 119.9172 26.17518 7 FALSE 1 1 1.1 8 119.9172 26.17518 8 FALSE 1 1 1.1 9 119.9173 26.17515 9 FALSE 1 1 1.1 10 119.9173 26.17515 10 FALSE 1 1 1.1 做一個假資料來畫：著色基準檔 #做一個假資料來畫 #prevalence設為亂數rnorm(需要的亂數個數) mydata&lt;-data.frame(NAME_2=tw_new$T_Name, id=tw_new$T_UID, prevalence=rnorm(length(tw_new$T_UID))) head(mydata) NAME_2 id prevalence 1 \\xa6\\xa8\\xa5\\\\\\xc2\\xed 178 1.0551637 2 \\xa8ΥV\\xb6m 164 -0.6307466 3 \\xb3\\xc1\\xbcd\\xb6m 118 -1.2255327 4 \\xba\\xf1\\xaeq\\xb6m 376 0.1314583 5 \\xc4\\xf5\\xc0\\xac\\xb6m 369 1.3665832 6 \\xa5Ф\\xa4\\xc2\\xed 78 -0.3132549 處理中文編碼 利用iconv將不知所以然的代碼（685\\2）轉為看得懂的中文 #from big5 to utf-8 mydata$NAME_2&lt;-iconv(as.character(mydata$NAME_2), #NAME_2原本是factor from=&quot;big5&quot;, to = &quot;UTF-8&quot;) head(mydata,10) NAME_2 id prevalence 1 成功鎮 178 1.0551637 2 佳冬鄉 164 -0.6307466 3 麥寮鄉 118 -1.2255327 4 綠島鄉 376 0.1314583 5 蘭嶼鄉 369 1.3665832 6 田中鎮 78 -0.3132549 7 社頭鄉 83 1.2072224 8 竹田鄉 157 0.7312959 9 萬丹鄉 148 1.4849184 10 三灣鄉 64 0.6094254 合併的圖檔與著色基準檔 最後將有prevalence的假數據mydata和經緯度資料tw_new.df合併, 用merge() final.plot&lt;-merge(tw_new.df,mydata,by=&quot;id&quot;,all.x=T) head(final.plot,10) id long lat order hole piece group NAME_2 prevalence 1 1 119.9170 26.17518 1 FALSE 1 1.1 南竿鄉 0.9584632 2 1 119.9171 26.17517 2 FALSE 1 1.1 南竿鄉 0.9584632 3 1 119.9171 26.17518 3 FALSE 1 1.1 南竿鄉 0.9584632 4 1 119.9171 26.17518 4 FALSE 1 1.1 南竿鄉 0.9584632 5 1 119.9171 26.17518 5 FALSE 1 1.1 南竿鄉 0.9584632 6 1 119.9172 26.17518 6 FALSE 1 1.1 南竿鄉 0.9584632 7 1 119.9172 26.17518 7 FALSE 1 1.1 南竿鄉 0.9584632 8 1 119.9172 26.17518 8 FALSE 1 1.1 南竿鄉 0.9584632 9 1 119.9173 26.17515 9 FALSE 1 1.1 南竿鄉 0.9584632 10 1 119.9173 26.17515 10 FALSE 1 1.1 南竿鄉 0.9584632 畫台灣面量圖 library(RColorBrewer) #配色用brewer.pal( 9 , &quot;Reds&quot; ) twcmap&lt;-ggplot() + geom_polygon(data = final.plot, aes(x = long, y = lat, group = group, fill = prevalence), color = &quot;black&quot;, size = 0.25) + coord_map()+#維持地圖比例 scale_fill_gradientn(colours = brewer.pal(9,&quot;Reds&quot;))+ theme_void()+ labs(title=&quot;Prevalence of X in Taiwan&quot;) twcmap 8.4.1 ggmap+面量圖 library(ggmap) twmap &lt;- get_googlemap(center = c(lon=120.58,lat=23.58), zoom = 7,language = &quot;zh-TW&quot;) ggmap(twmap)+ #ggmap geom_polygon(data = final.plot, #面量圖 aes(x = long, y = lat, group = group, fill = prevalence), color = &quot;grey80&quot;, size = 0.1,alpha = 0.5) + scale_fill_gradientn(colours = brewer.pal(9,&quot;Reds&quot;)) ##Heatmap Heatmap熱度圖使用顏色的深淺來表示數值的大小，通常會搭配XY兩軸的變量，所以使用一張圖就能表示三個維度的資訊，在ggplot2套件中，可以使用geom_tile()來畫Heatmap，以下以NBA球員的資料作為範例，希望能透過Heatmap來呈現球員表現的差異。 首先先將檔案讀入 #讀.csv檔案 nba &lt;- read.csv(&quot;http://datasets.flowingdata.com/ppg2008.csv&quot;) head(nba) ## Name G MIN PTS FGM FGA FGP FTM FTA FTP X3PM X3PA X3PP ORB DRB ## 1 Dwyane Wade 79 39 30 10.8 22 0.49 7.5 9.8 0.76 1.1 3.5 0.32 1.1 3.9 ## 2 LeBron James 81 38 28 9.7 20 0.49 7.3 9.4 0.78 1.6 4.7 0.34 1.3 6.3 ## 3 Kobe Bryant 82 36 27 9.8 21 0.47 5.9 6.9 0.86 1.4 4.1 0.35 1.1 4.1 ## 4 Dirk Nowitzki 81 38 26 9.6 20 0.48 6.0 6.7 0.89 0.8 2.1 0.36 1.1 7.3 ## 5 Danny Granger 67 36 26 8.5 19 0.45 6.0 6.9 0.88 2.7 6.7 0.40 0.7 4.4 ## 6 Kevin Durant 74 39 25 8.9 19 0.48 6.1 7.1 0.86 1.3 3.1 0.42 1.0 5.5 ## TRB AST STL BLK TO PF ## 1 5.0 7.5 2.2 1.3 3.4 2.3 ## 2 7.6 7.2 1.7 1.1 3.0 1.7 ## 3 5.2 4.9 1.5 0.5 2.6 2.3 ## 4 8.4 2.4 0.8 0.8 1.9 2.2 ## 5 5.1 2.7 1.0 1.4 2.5 3.1 ## 6 6.5 2.8 1.3 0.7 3.0 1.8 為了做圖，將寬表轉長表，寬表與長表的概念可參見6.8 library(reshape2) #for melt() nba.m &lt;- melt(nba,id.vars = &quot;Name&quot;) #寬表轉長表,以名字作依據 head(nba.m,10) ## Name variable value ## 1 Dwyane Wade G 79 ## 2 LeBron James G 81 ## 3 Kobe Bryant G 82 ## 4 Dirk Nowitzki G 81 ## 5 Danny Granger G 67 ## 6 Kevin Durant G 74 ## 7 Kevin Martin G 51 ## 8 Al Jefferson G 50 ## 9 Chris Paul G 78 ## 10 Carmelo Anthony G 66 將Geometric objects指定為geom_tile()，完成Heatmap library(ggplot2) #for ggplot() ggplot(nba.m, aes(variable, Name)) + #aes(x,y) geom_tile(aes(fill = value),colour = &quot;white&quot;)+ #geom_tile: 區塊著色 scale_fill_gradient(low = &quot;white&quot;,high = &quot;steelblue&quot;) #數值低：白色 看上圖可以發現，因為G欄資料明顯大於其他欄位，導致顏色差異不明顯，為了解決此問題，將個欄位的資料標準化處理，這邊使用到apply函式 apply()有類似for迴圈的功能 apply(Data, MARGIN, FUN,…) Data：矩陣（Matrix），Data Frame MARGIN：1=row, 2=column FUN：函數 …：函數要用的參數 nba[,2:21]&lt;-apply(nba[,2:21], 2, scale) #scale處理，將數值轉為平均=0 head(nba,2) ## Name G MIN PTS FGM FGA FGP FTM FTA FTP X3PM X3PA X3PP ## 1 Dwyane Wade 0.62 1.00 3.2 2.9 2.6 0.51 1.9 2.1 -0.74 -0.11 0.13 -0.157 ## 2 LeBron James 0.77 0.61 2.6 2.0 1.7 0.46 1.8 1.9 -0.52 0.49 0.70 0.027 ## ORB DRB TRB AST STL BLK TO PF ## 1 -0.272 -0.35 -0.33 1.7 2.6 1.21 1.8 -0.3 ## 2 -0.061 1.01 0.66 1.5 1.4 0.86 1.1 -1.4 nba.m &lt;- melt(nba) ##寬轉長 ggplot(nba.m, aes(variable, Name)) + geom_tile(aes(fill = value),colour = &quot;white&quot;)+ #geom_tile: 區塊著色 scale_fill_gradient(low = &quot;white&quot;,high = &quot;steelblue&quot;) #數值低：白色 以上範例之參考資料為How to Make a Heatmap – a Quick and Easy Solution 8.5 Treemap Treemap(矩形式樹狀結構繪圖法)是以二維平面的方式展示包含階層結構（hierarchical）形式的統計資訊，在R中可以使用treemapify(Wilkins 2019) packages install.packages(&quot;devtools&quot;) library(devtools) install_github(&quot;wilkox/ggfittext&quot;) install_github(&quot;wilkox/treemapify&quot;) library(treemapify) 以G20 Dataset為例，二十國集團（英語：Group of Twenty，縮寫：G20）是一個國際經濟合作論壇，於1999年12月16日在德國柏林成立，屬於布雷頓森林體系框架內非正式對話的一種機制，由七國集團（美國、英國、法國、德國、義大利、日本、加拿大），金磚五國（中國、印度、巴西、俄羅斯、南非），七個重要經濟體（澳大利亞、墨西哥、韓國、土耳其、印尼、沙烏地阿拉伯、阿根廷），以及歐盟組成。按照慣例，國際貨幣基金組織與世界銀行列席該組織的會議。二十國集團的GDP總量約佔全球GDP的85％，貿易佔全球貿易總額的80%以上，人口約佔全球人口的2/3。（維基百科） G20 Dataset包含20個國家的資訊，資料欄位有： Region 國家所在區域 Country 國家名稱 Trade.mil.USD 總貿易額，以百萬為單位 Nom.GDP.mil.USD 名義國內生產總值，以百萬為單位 HDI 人類發展指數（維基百科） Population 人口數 Economic.classification 經濟狀況分類 首先將資料讀入，並用str()函式觀察資料型態 data(G20)#範例資料 str(G20) ## &#39;data.frame&#39;: 20 obs. of 6 variables: ## $ region : Factor w/ 8 levels &quot;Africa&quot;,&quot;Asia&quot;,..: 1 6 6 6 8 8 2 2 2 2 ... ## $ country : Factor w/ 20 levels &quot;Argentina&quot;,&quot;Australia&quot;,..: 16 20 4 13 3 1 5 12 17 9 ... ## $ gdp_mil_usd : int 384315 15684750 1819081 1177116 2395968 474954 8227037 5963969 1155872 1824832 ... ## $ hdi : num 0.629 0.937 0.911 0.775 0.73 0.811 0.699 0.912 0.909 0.554 ... ## $ econ_classification: Factor w/ 2 levels &quot;Advanced&quot;,&quot;Developing&quot;: 2 1 1 2 2 2 2 1 1 2 ... ## $ hemisphere : Factor w/ 2 levels &quot;Northern&quot;,&quot;Southern&quot;: 2 1 1 1 2 2 1 1 1 1 ... 用搭配ggplot()函數，使用geom_treemap()做圖 ggplot(G20, aes(area = gdp_mil_usd, fill = hdi)) + geom_treemap() 看函式名稱不難了解ggplotify()也是基於ggplot2套件開發，所以可以使用ggplot2的圖形設定參數改變圖形樣式，由於數字越大顏色越深比較符合視覺化的常理，所以這邊使用ggplot2的scale_fill_gradient()函式指定數值高低所需的顏色 ggplot(G20, aes(area = gdp_mil_usd, fill = hdi, label = country)) + geom_treemap() + scale_fill_gradient(low = &quot;white&quot;,high = &quot;steelblue&quot;) #指定高低顏色 也可使用geom_treemap_text()加上文字標籤。 ggplot(G20, aes(area = gdp_mil_usd, fill = hdi, label = country)) + geom_treemap() + scale_fill_gradient(low = &quot;white&quot;,high = &quot;steelblue&quot;) #指定高低顏色+ geom_treemap_text(fontface = &quot;italic&quot;, colour = &quot;white&quot;, place = &quot;centre&quot;, grow = TRUE) ## geom_treemap_text: na.rm = FALSE, padding.x = 1, padding.y = 1, place = centre, min.size = 4, grow = TRUE, reflow = FALSE, fixed = NULL, layout = squarified, start = bottomleft ## stat_identity: na.rm = FALSE ## position_identity 完整做圖程式碼如下： ## install.packages(&quot;devtools&quot;) 第一次使用前需要安裝 ## library(devtools) ## install_github(&quot;wilkox/treemapify&quot;) library(treemapify) data(G20)#載入範例資料 ggplot(G20, aes(area = gdp_mil_usd, fill = hdi, label = country)) + geom_treemap() + scale_fill_gradient(low = &quot;white&quot;,high = &quot;steelblue&quot;) #指定高低顏色+ geom_treemap_text(fontface = &quot;italic&quot;, colour = &quot;white&quot;, place = &quot;centre&quot;, grow = TRUE) treemap(Tennekes 2017) package也提供相同的功能 library(treemap) data(GNI2014) treemap(GNI2014, index=c(&quot;continent&quot;, &quot;iso3&quot;), #分組依據 vSize=&quot;population&quot;, #區塊大小 vColor=&quot;GNI&quot;, #顏色深淺 type=&quot;value&quot;) 參考資料 8.6 參考文件與資源 官方網站文件 RStudio製作的ggplot cheat sheet DataCamp互動式課程1 Data Visualization with ggplot2 (Part 1) DataCamp互動式課程2 Data Visualization with ggplot2 (Part 2) DataCamp互動式課程3 Data Visualization with ggplot2 (Part 3) References "],
["InteractiveGraphics.html", "9 互動式資料呈現 9.1 ggvis 9.2 Plot.ly 9.3 Shiny簡介", " 9 互動式資料呈現 在R中有多種互動式資料呈現方式，除了傳統的GGobi、iPlots、identify等套件外，結合網頁呈現的互動畫呈現方式有更多的彈性，以下介紹幾種好用的互動式套件： ggvis googleVis Plot.ly 使用者可依需求選擇使用。 最後再介紹Shiny，一個RStudio推出供R語言使用的網頁應用框架，使用者可以將做好的互動式圖表用Shiny部署網頁，並將分析結果以網頁的方式分享給別人。 9.1 ggvis ggvis(Chang and Wickham 2019) 是RStudio開發的互動式繪圖套件，繪圖語法與ggplot2(Wickham, Chang, et al. 2020)套件類似，基本概念是使用R做資料處理與分析，然後利用網頁的方式做視覺化呈現。如果使用RStudio IDE，透過ggvis套件畫的圖會呈現在右下角的Viewer視窗中。 使用ggvis套件時，必須先安裝與載入 install.packages(&quot;ggvis&quot;) library(ggvis) p &lt;- ggvis(mtcars, x = ~wt, y = ~mpg) layer_points(p) Renderer: SVG | Canvas Download 增加input_slider函數，讓使用者可以調整圖形畫圖方式（因書本輸出格式，不支援動態畫圖，請將程式碼複製貼上到RStudio中就能看到互動式畫圖的樣子） p&lt;-ggvis(mtcars,~wt) layer_histograms(p,width = input_slider(0, 2, step = 0.10, label = &quot;width&quot;), center = input_slider(0, 2, step = 0.05, label = &quot;center&quot;)) ## Warning: `group_by_()` is deprecated as of dplyr 0.7.0. ## Please use `group_by()` instead. ## See vignette(&#39;programming&#39;) for more help ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. ## Warning: `mutate_()` is deprecated as of dplyr 0.7.0. ## Please use `mutate()` instead. ## See vignette(&#39;programming&#39;) for more help ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. ## Warning: Can&#39;t output dynamic/interactive ggvis plots in a knitr document. ## Generating a static (non-dynamic, non-interactive) version of the plot. Renderer: SVG | Canvas Download 除了input_slider()外，ggvis還提供以下互動式輸入介面： input_checkbox() input_checkboxgroup() input_numeric() input_radiobuttons() input_select() input_text() 其他詳細使用說明請參考官網 ##googleVis googleVis(Gesmann and de Castillo 2020) package是基於Google Chart API開發的R套件，使用前需要先安裝與載入。 install.packages(&quot;googleVis&quot;) library(googleVis) 如果想要一次看完所有作圖範例，可用以下指令（執行完畢需要一點時間） demo(googleVis) googleVis套件提供多種繪圖方式，包括： 一維資料做圖 gvisHistogram 類別-數值資料做圖 gvisPieChart gvisGauge gvisBarChart gvisColumnChart gvisCandlestickChart 數值-數值資料做圖 gvisLineChart gvisAreaChart gvisSteppedAreaChart gvisScatterChart gvisAnnotationChart 數值-數值-數值資料做圖 gvisBubbleChart 地圖相關 gvisIntensityMap gvisGeoChart gvisMap 其他圖形 gvisOrgChart gvisTreeMap gvisSankey gvisComboChart gvisCalendar gvisTimeline 詳細使用說明請參考googleVis套件說明 df=data.frame(country=c(&quot;US&quot;, &quot;GB&quot;, &quot;BR&quot;), val1=c(10,13,14), val2=c(23,12,32)) Line &lt;- gvisLineChart(df) plot(Line) require(datasets) states &lt;- data.frame(state.name, state.x77) GeoStates &lt;- gvisGeoChart(states, &quot;state.name&quot;, &quot;Illiteracy&quot;, options=list(region=&quot;US&quot;, displayMode=&quot;regions&quot;, resolution=&quot;provinces&quot;, width=600, height=400)) plot(GeoStates) AndrewMap &lt;- gvisMap(Andrew, &quot;LatLong&quot; , &quot;Tip&quot;, options=list(showTip=TRUE, showLine=TRUE, enableScrollWheel=TRUE, mapType=&#39;terrain&#39;, useMapTypeControl=TRUE)) plot(AndrewMap) 其他Google Chart可以做的圖形種類，可以參考Chart Gallery 9.2 Plot.ly Plotly是一個線上分析與視覺化的工具，如需線上作圖，可至https://plot.ly/create/ 建立帳號並開始作圖。Plotly也提供套件R使用，使用者可以透過安裝plotly(Sievert et al. 2020) package在R中畫基於Plotly.js (d3.js + stack.gl)的圖表和地圖。除了R的套件外，還有Python, MATLAB, Perl, Julia, Arduino等套件可供使用。 使用plotly套件時，必須先安裝與載入 install.packages(&quot;plotly&quot;) library(plotly) d &lt;- diamonds[sample(nrow(diamonds), 1000), ] plot_ly(d, x = ~carat, y = ~price, color = ~carat, size = ~carat, text = ~paste(&quot;Clarity: &quot;, clarity)) ## Warning: `arrange_()` is deprecated as of dplyr 0.7.0. ## Please use `arrange()` instead. ## See vignette(&#39;programming&#39;) for more help ## This warning is displayed once every 8 hours. ## Call `lifecycle::last_warnings()` to see where this warning was generated. ## Warning: `line.width` does not currently support multiple values. p &lt;- ggplot(data = d, aes(x = carat, y = price)) + geom_point(aes(text = paste(&quot;Clarity:&quot;, clarity))) + geom_smooth(aes(colour = cut, fill = cut)) + facet_wrap(~ cut) ggplotly(p) Plotly提供免費的圖形分享空間，方便使用者將做好的圖上傳到網路上，若想使用Plotly提供圖形分享空間，必須要先申請Plotly帳號，透過此網頁取得API keys，並使用下列程式碼設定帳號與API keys Sys.setenv(&quot;plotly_username&quot;=&quot;your_plotly_username&quot;) Sys.setenv(&quot;plotly_api_key&quot;=&quot;your_api_key&quot;) 設定完基本資料後，使用plotly_POST函式將plotly物件p上傳到指定路徑(filename)的網路空間中。 plotly_POST(p, filename = &quot;file-name&quot;) 參考資料 Plotly官網 Plotly API for R Plotly cheat sheet 9.3 Shiny簡介 Shiny是RStudio推出供R語言使用的網頁應用框架（Web application framework），透過Shiny，使用者可以輕鬆地將資料分析結果轉換成互動式的網頁應用，不用另外學習其他網頁程式語言（如HTML, CSS, JavaScript等），若要使用Shiny，RStudio IDE提供完整測試預覽功能，建議一起使用。使用前必須先安裝並載入shiny (Chang et al. 2020) package install.packages(&quot;shiny&quot;) library(shiny) shiny package內提供11個網頁部署範例，使用者可以直接用下列程式碼觀看相關範例的呈現效果與原始碼 runExample(&quot;01_hello&quot;) # a histogram runExample(&quot;02_text&quot;) # tables and data frames runExample(&quot;03_reactivity&quot;) # a reactive expression runExample(&quot;04_mpg&quot;) # global variables runExample(&quot;05_sliders&quot;) # slider bars runExample(&quot;06_tabsets&quot;) # tabbed panels runExample(&quot;07_widgets&quot;) # help text and submit buttons runExample(&quot;08_html&quot;) # Shiny app built from HTML runExample(&quot;09_upload&quot;) # file upload wizard runExample(&quot;10_download&quot;) # file download wizard runExample(&quot;11_timer&quot;) # an automated timer 在RStudio內，可直接透過新增專案 New Project新增Shiny應用程式 Shiny應用程式包括兩個元件： ui.R : 使用者介面（前端）程式碼 user-interface script server.R : 伺服器端（後端）程式碼 server script 使用者介面程式碼ui.R控制Shiny應用程式的外觀，伺服器端程式碼server.R控制Shiny應用程式的功能。 ui.R範例 library(shiny) shinyUI(fluidPage( # 網頁標題 titlePanel(&quot;Hello Shiny!&quot;), # Sidebar + slider sidebarLayout( sidebarPanel( sliderInput(&quot;bins&quot;, &quot;Number of bins:&quot;, min = 1, max = 50, value = 30) ), # 圖形呈現 mainPanel( plotOutput(&quot;distPlot&quot;) ) ) )) server.R範例 library(shiny) shinyServer(function(input, output) { # 將直方圖Histogram存入distPlot變數，在UI端用plotOutput呈現 output$distPlot &lt;- renderPlot({ x &lt;- faithful[, 2] # Old Faithful Geyser data # input$bins是用UI端的Sidebar + slider調整 bins &lt;- seq(min(x), max(x), length.out = input$bins + 1) hist(x, breaks = bins, col = &#39;darkgray&#39;, border = &#39;white&#39;) }) }) 若想使用介紹過的Plotly與Shiny結合，可參考此教學網頁。 更深入的Shiny教學，可參考使用R Shiny設計資料科學應用程式，為專為Shiny App開發撰寫的電子書，並深入解說如何使用Shiny建立新冠肺炎COVID-19的案例數地圖與儀表板。 參考資料 Shiny官網 Shiny cheat sheet References "],
["datamining.html", "10 資料探勘 10.1 什麼是資料探勘 10.2 Regression 迴歸 10.3 Decision Trees 決策樹 10.4 Clustering 分群 10.5 Association Rules 關聯式規則 10.6 Open Source Packages 10.7 模型驗證 10.8 Case Study 10.9 參考資料", " 10 資料探勘 10.1 什麼是資料探勘 資料探勘（Data mining）是用人工智慧、機器學習、統計學的交叉方法，在相對較大型的資料集中發現模式的計算過程。使用資料探勘技術可以建立從輸入資料學習新資訊，變成智慧的演算法或資料模式，用來預測事件或協助決策。所以，當資料太少或太髒的時候，資料探勘的效力會被影響。 資料探勘要派上用場，必須有以下條件： 有一些模式/模型可學 很難定義這些模式/模型 有資料可學這些模式/模型 資料探勘的應用範例如下： 天氣預測 搜尋建議、購物建議 股市預測 臉部辨識、指紋辨識 垃圾郵件標記 尿布啤酒 資料探勘可分為監督式學習與非監督式學習，監督式學習的特點是訓練資料中有正確答案，由輸入物件和預期輸出所組成，而演算法可以由訓練資料中學到或建立一個模式，並依此模式推測新的實例；非監督式學習則不用提供正確答案，也就是不需要人力來輸入標籤，單純利用訓練資料的特性，將資料分群分組。 此兩種學習可解決不同的問題，條列如下： Supervised learning 監督式學習 Regression 迴歸：真實的’值’（股票、氣溫） Classification 分類：分兩類（P/N, Yes/No, M/F, Sick/Not sick）/分多類 (A/B/C/D) Unsupervised learning 非監督式學習 Clustering 分群 Association Rules 關聯式規則 在監督式學習中常見的資料探勘演算法如下： Linear Regression 線性迴歸 Logistic Regression 羅吉斯迴歸、邏輯迴歸 Support Vector Machines 支持向量機 Decision Trees 決策樹 K-Nearest Neighbor Neural Networks 神經網路 Deep Learning 深度學習 在非監督式學習中常見的資料探勘演算法如下： Hierarchical clustering 階層式分群 K-means clustering Neural Networks 神經網路 Deep Learning 深度學習 以下介紹在R中使用各類演算法的方法 10.2 Regression 迴歸 Regression Analysis 迴歸分析主要用在了解兩個或多個變數間是否相關、相關方向與強度，並建立數學模型以便觀察特定變數來預測研究者感興趣的變數，常見的迴歸分析演算法包括： Linear Regression 線性迴歸 Logistic Regression 羅吉斯迴歸、邏輯迴歸 10.2.1 Linear Regression 線性迴歸 首先，嘗試將Linear Regression 線性迴歸用在NBA的資料看看，做NBA得分與上場分鐘數的線性迴歸觀察 #讀入SportsAnalytics package library(SportsAnalytics) #擷取2015-2016年球季球員資料 NBA1516&lt;-fetch_NBAPlayerStatistics(&quot;15-16&quot;) library(ggplot2) ggplot(NBA1516,aes(x=TotalMinutesPlayed,y=TotalPoints))+ geom_point()+geom_smooth(method = &quot;glm&quot;) 在R中，最基本的簡單線性迴歸分析為lm()，使用方法為lm(formula,data=資料名稱)，搭配formula使用，formula的撰寫方法為：依變項~自變項1＋自變項2＋…. lm(TotalPoints~TotalMinutesPlayed,data =NBA1516) ## ## Call: ## lm(formula = TotalPoints ~ TotalMinutesPlayed, data = NBA1516) ## ## Coefficients: ## (Intercept) TotalMinutesPlayed ## -85.907 0.493 由此可知總得分數TotalPoints等於0.4931 * 總出場分鐘數 -85.9071 TotalPoints = 0.4931 * TotalMinutesPlayed -85.9071 更被廣泛使用的是廣義線性迴歸模型generalized linear models (glm)，函數為glm()，使用方法與lm()類似，包括了線性迴歸模型和邏輯迴歸模型。 如果需要修改預設模型，可設定family參數： - `family=&quot;gaussian&quot;` 線性模型模型 - `family=&quot;binomial&quot;` 邏輯迴歸模型 - `family=&quot;poisson&quot;` 卜瓦松迴歸模型 Gaussian distribution高斯函數是常態分布的密度函數 Binomial distribution二項分布是n個獨立的是/非試驗中成功的次數的離散機率分布 Poisson distribution次數分佈： 某一服務設施在一定時間內受到的服務請求的次數 公車站的候客人數 機器故障數 自然災害發生的次數 DNA序列的變異數….. 以下為使用多變量線性迴歸來分析得分與上場分鐘數和兩分球出手數的關係範例 # e+01: 10^1 / e-04: 10^(-4) glm(TotalPoints~TotalMinutesPlayed+FieldGoalsAttempted, data =NBA1516) ## ## Call: glm(formula = TotalPoints ~ TotalMinutesPlayed + FieldGoalsAttempted, ## data = NBA1516) ## ## Coefficients: ## (Intercept) TotalMinutesPlayed FieldGoalsAttempted ## -1.80e+01 -2.35e-04 1.26e+00 ## ## Degrees of Freedom: 475 Total (i.e. Null); 473 Residual ## Null Deviance: 9.9e+07 ## Residual Deviance: 2160000 AIC: 5370 由此可知總得分數等於-0.0002347 * 總出場分鐘數 + 1.255794 * 兩分球出手數 -17.99 TotalPoints = -0.0002347 * TotalMinutesPlayed + 1.255794 * FieldGoalsAttempted -17.99 如需使用多變量線性迴歸來分析得分與上場分鐘數和兩分球出手數和守備位置的關係，可修改formula glm(TotalPoints~TotalMinutesPlayed+FieldGoalsAttempted+Position, data =NBA1516) ## ## Call: glm(formula = TotalPoints ~ TotalMinutesPlayed + FieldGoalsAttempted + ## Position, data = NBA1516) ## ## Coefficients: ## (Intercept) TotalMinutesPlayed FieldGoalsAttempted ## 22.85222 -0.00654 1.27572 ## PositionPF PositionPG PositionSF ## -39.41633 -65.03465 -38.52230 ## PositionSG ## -52.17514 ## ## Degrees of Freedom: 474 Total (i.e. Null); 468 Residual ## (1 observation deleted due to missingness) ## Null Deviance: 9.9e+07 ## Residual Deviance: 2e+06 AIC: 5320 # e+01: 10^1 / e-04: 10^(-4) 由此可知總得分數TotalPoints和上場分鐘數和兩分球出手數和守備位置的關係為： TotalPoints = -0.0065 * TotalMinutesPlayed + 1.28 FieldGoalsAttempted +22.85 + 22.85 PositionPF + -65.03 * PositionPG + -38.52 * PositionSF + -52.18 * PositionSG 由上述結果可發現，守備位置的變項被轉為虛擬變項 Dummy Variable：PositionPF、PositionPG、PositionSF、PositionSG，如果是控球後衛（PG），會得到： PositionPF=0 PositionPG=1 PositionSF=0 PositionSG=0 可能有人會問，那中鋒去哪了？其實中鋒被當作基準項，也就是當守備位置是中鋒(C)時，會得到： PositionPF=0 PositionPG=0 PositionSF=0 PositionSG=0 總結以上，多變量線性迴歸分析有下列特色： 假設：各變數相互獨立！ 若自變項X是類別變項，需要建立虛擬變項 在R裡，類別變項請記得轉成factor，R會自動建立虛擬變項 用在依變數為連續變數，自變數為連續變數或虛擬變數的場合 10.2.2 Logistic Regression 羅吉斯迴歸 Logistic Regression 羅吉斯迴歸常用在依變數為二元變數（非0即1）的場合，如： - 生病/沒生病 - 錄取/不錄取 - family=\"binomial\" 邏輯迴歸模型 以分數資料為例，分析為什麼錄取/不錄取？ mydata &lt;- read.csv(&quot;https://raw.githubusercontent.com/CGUIM-BigDataAnalysis/BigDataCGUIM/master/binary.csv&quot;) # GRE:某考試成績, GPA:在校平均成績, rank:學校聲望 head(mydata) admit gre gpa rank 0 380 3.6 3 1 660 3.7 3 1 800 4.0 1 1 640 3.2 4 0 520 2.9 4 1 760 3.0 2 mydata$rank &lt;- factor(mydata$rank) mylogit &lt;- glm(admit ~ gre + gpa + rank, data = mydata, family = &quot;binomial&quot;) sum&lt;-summary(mylogit) sum$coefficients ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -3.9900 1.1400 -3.5 0.00047 ## gre 0.0023 0.0011 2.1 0.03847 ## gpa 0.8040 0.3318 2.4 0.01539 ## rank2 -0.6754 0.3165 -2.1 0.03283 ## rank3 -1.3402 0.3453 -3.9 0.00010 ## rank4 -1.5515 0.4178 -3.7 0.00020 10.2.3 最佳模型篩選 到底該用哪個模型來預測，會得到最準確的結果？在迴歸模型中，常用的判斷準則包括： Akaike’s Information Criterion (AIC) Bayesian Information Criterion (BIC) AIC和BIC都是數值越小越好，以下建立三個模型，並比較其AIC， OneVar&lt;-glm(TotalPoints~TotalMinutesPlayed,data =NBA1516) TwoVar&lt;-glm(TotalPoints~TotalMinutesPlayed+FieldGoalsAttempted, data =NBA1516) ThreeVar&lt;-glm(TotalPoints~TotalMinutesPlayed+FieldGoalsAttempted+Position, data =NBA1516) c(OneVar$aic,TwoVar$aic,ThreeVar$aic) ## [1] 6339 5367 5322 在建立迴歸模型時，常會遇到到底該放多少參數？所有參數都有用嗎？這類的問題，我們可以藉由觀察coefficients來判斷參數在模型中的“實用程度” sum2&lt;-summary(TwoVar) sum2$coefficients ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) -1.8e+01 5.6598 -3.178 1.6e-03 ## TotalMinutesPlayed -2.3e-04 0.0095 -0.025 9.8e-01 ## FieldGoalsAttempted 1.3e+00 0.0222 56.467 2.5e-212 sum3&lt;-summary(ThreeVar) sum3$coefficients ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 22.8522 9.0147 2.53 1.2e-02 ## TotalMinutesPlayed -0.0065 0.0092 -0.71 4.8e-01 ## FieldGoalsAttempted 1.2757 0.0216 58.93 1.1e-218 ## PositionPF -39.4163 9.9365 -3.97 8.4e-05 ## PositionPG -65.0346 10.2693 -6.33 5.6e-10 ## PositionSF -38.5223 10.4882 -3.67 2.7e-04 ## PositionSG -52.1751 9.9853 -5.23 2.6e-07 10.3 Decision Trees 決策樹 決策樹是在樹狀目錄中建立一系列分割，以建立模型。這些分割會表示成「節點」(Node)。每次發現輸入資料行與可預測資料行有明顯地相互關聯時，此演算法就會在模型中加入一個節點。演算法決定分岔的方式不同，視它預測連續資料行或分隔資料行而定。 以下介紹常見的Classification And Regression Tree (CART)，使用前須先安裝rpart packages (Therneau and Atkinson 2019) install.packages(&quot;rpart&quot;) 以前述NBA資料為例，嘗試用用籃板/三分/助攻/抄截數據來判斷守備位置，建立決策樹的函數為rpart()，使用方式為rpart(formula, data) library(rpart) DT&lt;-rpart(Position~Blocks+ThreesMade+Assists+Steals,data=NBA1516) DT ## n=475 (1 observation deleted due to missingness) ## ## node), split, n, loss, yval, (yprob) ## * denotes terminal node ## ## 1) root 475 360 PF (0.15 0.23 0.21 0.18 0.23) ## 2) ThreesMade&lt; 2.5 132 74 C (0.44 0.35 0.098 0.053 0.061) ## 4) Blocks&gt;=4.5 89 37 C (0.58 0.38 0.011 0.011 0.011) * ## 5) Blocks&lt; 4.5 43 31 PF (0.14 0.28 0.28 0.14 0.16) ## 10) Steals&lt; 2.5 29 19 PF (0.17 0.34 0.14 0.21 0.14) * ## 11) Steals&gt;=2.5 14 6 PG (0.071 0.14 0.57 0 0.21) * ## 3) ThreesMade&gt;=2.5 343 240 SG (0.035 0.19 0.25 0.23 0.29) ## 6) Assists&gt;=1.7e+02 96 39 PG (0.031 0.052 0.59 0.15 0.18) * ## 7) Assists&lt; 1.7e+02 247 160 SG (0.036 0.24 0.12 0.26 0.34) ## 14) Blocks&gt;=20 80 42 PF (0.062 0.48 0 0.26 0.2) ## 28) Steals&lt; 60 58 21 PF (0.069 0.64 0 0.14 0.16) * ## 29) Steals&gt;=60 22 9 SF (0.045 0.045 0 0.59 0.32) * ## 15) Blocks&lt; 20 167 99 SG (0.024 0.13 0.17 0.26 0.41) ## 30) Assists&lt; 82 110 68 SG (0.027 0.18 0.091 0.32 0.38) ## 60) Blocks&gt;=4.5 63 39 SF (0.032 0.29 0.016 0.38 0.29) ## 120) ThreesMade&lt; 14 19 9 PF (0.11 0.53 0 0.26 0.11) * ## 121) ThreesMade&gt;=14 44 25 SF (0 0.18 0.023 0.43 0.36) ## 242) Blocks&lt; 9.5 17 7 SF (0 0.18 0.059 0.59 0.18) * ## 243) Blocks&gt;=9.5 27 14 SG (0 0.19 0 0.33 0.48) * ## 61) Blocks&lt; 4.5 47 23 SG (0.021 0.043 0.19 0.23 0.51) * ## 31) Assists&gt;=82 57 31 SG (0.018 0.035 0.33 0.16 0.46) ## 62) ThreesMade&lt; 37 17 5 PG (0 0.12 0.71 0.059 0.12) * ## 63) ThreesMade&gt;=37 40 16 SG (0.025 0 0.17 0.2 0.6) * #控球後衛（PG）、得分後衛（SG）、小前鋒（SF）、大前鋒（PF）和中鋒（C） par(mfrow=c(1,1), mar = rep(1,4)) #下,左,上,右 plot(DT) text(DT, use.n=F, all=F, cex=1) #控球後衛（PG）、得分後衛（SG）、小前鋒（SF）、大前鋒（PF）和中鋒（C） 可以看出預設的plot()畫出來的圖很難看懂，可以改用rpart.plot package (Milborrow 2019)裡面的prp() install.packages(&quot;rpart.plot&quot;) #第一次使用前須先安裝 library(rpart.plot) prp(DT) 決策樹演算法決定節點的方式如下： Gini impurity Information gain Variance reduction 細節可參考維基百科 10.4 Clustering 分群 Clustering 分群的目的是將相近的觀察值作做分群，分群過程中，可能會遇到以下問題： 如何定義相近？ 如何分群？ 如何視覺化？ 如何解釋分群？ 10.4.1 Hierarchical clustering 階層式分群 An agglomerative approach Find closest two things Put them together Find next closest Requires A defined distance A merging approach Produces A tree showing how close things are to each other 如何定義相近？用距離distance的概念來定義相近。 Distance or similarity Continuous - euclidean distance Continuous - correlation similarity Binary - manhattan distance Pick a distance/similarity that makes sense for your problem Example distances - Euclidean \\[\\sqrt{(A_1-A_2)^2 + (B_1-B_2)^2 + \\ldots + (Z_1-Z_2)^2}\\] Example distances - Manhattan \\[|A_1-A_2| + |B_1-B_2| + \\ldots + |Z_1-Z_2|\\] Merging apporach Agglomerative 聚合 Single-linkage：取最小值 Complete-linkage：取最大值 Average-linkage：取平均值 Hierarchical clustering - hp vs. mpg Hierarchical clustering - #1 Hierarchical clustering - #2 Hierarchical clustering - #3 可用dist()函數計算距離，使用method=\"\"設定計算距離的依據 mtcars.mxs&lt;-as.matrix(mtcars) d&lt;-dist(mtcars.mxs) #預設為euclidean head(d) ## [1] 0.62 54.91 98.11 210.34 65.47 241.41 dist()函數可用方法包括： “euclidean”, “maximum”, “manhattan”, “canberra”, “binary” or “minkowski” d&lt;-dist(mtcars.mxs, method=&quot;manhattan&quot;) #計算manhattan距離 head(d) ## [1] 0.81 79.30 108.80 275.43 84.64 347.96 用hclust函數畫圖，必要參數是各觀察值的距離（可用dist()函數計算） par(mar=rep(2,4),mfrow=c(1,1)) hc&lt;-hclust(dist(mtcars.mxs)) #可用method參數設定聚合方法，預設為complete plot(hc) par(mar=rep(2,4),mfrow=c(1,1)) hc&lt;-hclust(dist(mtcars.mxs),method=&quot;average&quot;) #聚合方法為計算平均距離 plot(hc) clusterCut &lt;- cutree(hc, k=5) #分5群 sort(clusterCut) ## Mazda RX4 Mazda RX4 Wag Datsun 710 Merc 240D ## 1 1 1 1 ## Merc 230 Merc 280 Merc 280C Fiat 128 ## 1 1 1 1 ## Honda Civic Toyota Corolla Toyota Corona Fiat X1-9 ## 1 1 1 1 ## Porsche 914-2 Lotus Europa Ferrari Dino Volvo 142E ## 1 1 1 1 ## Hornet 4 Drive Valiant Merc 450SE Merc 450SL ## 2 2 2 2 ## Merc 450SLC Dodge Challenger AMC Javelin Hornet Sportabout ## 2 2 2 3 ## Duster 360 Camaro Z28 Pontiac Firebird Ford Pantera L ## 3 3 3 3 ## Cadillac Fleetwood Lincoln Continental Chrysler Imperial Maserati Bora ## 4 4 4 5 ggplot()+geom_point(data=mtcars, aes(x=hp,y=mpg,color=as.factor(clusterCut))) clusterCut &lt;- cutree(hc,h =4) #切在高度=4的地方（距離=4） sort(clusterCut) ## Mazda RX4 Mazda RX4 Wag Datsun 710 Hornet 4 Drive ## 1 1 2 3 ## Hornet Sportabout Valiant Duster 360 Merc 240D ## 4 5 6 7 ## Merc 230 Merc 280 Merc 280C Merc 450SE ## 8 9 9 10 ## Merc 450SL Merc 450SLC Cadillac Fleetwood Lincoln Continental ## 10 10 11 12 ## Chrysler Imperial Fiat 128 Honda Civic Toyota Corolla ## 13 14 15 16 ## Toyota Corona Dodge Challenger AMC Javelin Camaro Z28 ## 17 18 19 20 ## Pontiac Firebird Fiat X1-9 Porsche 914-2 Lotus Europa ## 21 22 23 24 ## Ford Pantera L Ferrari Dino Maserati Bora Volvo 142E ## 25 26 27 28 par(mar=rep(0.2,4),mfrow=c(1,1)) heatmap(mtcars.mxs) distxy &lt;- dist(mtcars.mxs) hClustering &lt;- hclust(distxy) plot(hClustering) Hierarchical clustering: summary - 可快速瀏覽觀察值與各欄位的關係 分群結果可能被以下參數影響： 計算距離的方法 分群依據 更改數值的大小 可能會遇到的問題： 有時會不太清楚要如何切割分群結果 10.4.2 K-means clustering 執行步驟 指定要分幾群 計算每一群的中心點 將各個物件/觀察值指定給最近的中心點 依照新的分群計算新的中心點 輸入 計算距離的資料（數值） 要分成幾群 # of clusters 預設個群的中間點位置 產出 計算出每’群‘的中心點 指定每個觀察值所在的’群‘ x&lt;-scale(mtcars$hp[-1]);y&lt;-scale(mtcars$mpg[-1]) plot(x,y,col=&quot;blue&quot;,pch=19,cex=2) text(x+0.05,y+0.05,labels=labelCar) kmeans() Important parameters: x, centers, iter.max, nstart dataFrame &lt;- data.frame(x,y) kmeansObj &lt;- kmeans(dataFrame,centers=3) names(kmeansObj) ## [1] &quot;cluster&quot; &quot;centers&quot; &quot;totss&quot; &quot;withinss&quot; &quot;tot.withinss&quot; ## [6] &quot;betweenss&quot; &quot;size&quot; &quot;iter&quot; &quot;ifault&quot; kmeansObj$cluster ## [1] 3 3 3 2 3 2 3 3 3 3 2 2 2 2 2 2 1 1 1 3 2 2 2 2 1 1 1 2 2 2 3 par(mar=rep(0.2,4)) plot(x,y,col=kmeansObj$cluster,pch=19,cex=2) points(kmeansObj$centers,col=1:3,pch=3,cex=3,lwd=3) Heatmaps set.seed(1234) dataMatrix &lt;- as.matrix(dataFrame)[sample(1:12),] kmeansObj &lt;- kmeans(dataMatrix,centers=3) par(mfrow=c(1,2), mar = c(2, 4, 0.1, 0.1)) image(t(dataMatrix)[,nrow(dataMatrix):1],yaxt=&quot;n&quot;) image(t(dataMatrix)[,order(kmeansObj$cluster)],yaxt=&quot;n&quot;) K-means注意事項 需要決定# of clusters 用眼睛/人工/特殊要求選 用 cross validation/information theory選 Determining the number of clusters K-means 沒有一定的結果 不同的 # of clusters 不同的 # of iterations kmeans(), k=2 kmeans(), k=3 kmeans(), k=4 10.5 Association Rules 關聯式規則 關聯式規則用於從大量數據中挖掘出有價值的數據項之間的相關關係，原則為不考慮項目的次序，而僅考慮其組合。著名的購物籃分析 (Market Basket Analysis)即為關聯式規則分析的應用。而Apriori演算法是挖掘布林關聯規則 (Boolean association rules) 頻繁項集的算法，在R中，可以使用arules(Hahsler et al. 2020) 套件來執行關聯式規則分析。 以下以超市資料為例，使用關聯式規則分析執行購物籃分析。 首先先讀入超市消費資料 # Load the libraries if (!require(&#39;arules&#39;)){ install.packages(&quot;arules&quot;); library(arules) #for Apriori演算法 } if (!require(&#39;datasets&#39;)){ install.packages(&quot;datasets&quot;); library(datasets) #for Groceries data } data(Groceries) # Load the data set Groceries@data@Dim #169 種商品，9835筆交易資料 ## [1] 169 9835 超市資料的原始樣貌為： 可使用arules套件中的apriori函數來實作apriori演算法 # Get the rules rules &lt;- apriori(Groceries, # data= Groceries parameter = list(supp = 0.001, conf = 0.8), #參數最低限度 control = list(verbose=F)) #不要顯示output options(digits=2) # Only 2 digits inspect(rules[1:5]) # Show the top 5 rules ## lhs rhs support confidence coverage lift ## [1] {liquor,red/blush wine} =&gt; {bottled beer} 0.0019 0.90 0.0021 11.2 ## [2] {curd,cereals} =&gt; {whole milk} 0.0010 0.91 0.0011 3.6 ## [3] {yogurt,cereals} =&gt; {whole milk} 0.0017 0.81 0.0021 3.2 ## [4] {butter,jam} =&gt; {whole milk} 0.0010 0.83 0.0012 3.3 ## [5] {soups,bottled beer} =&gt; {whole milk} 0.0011 0.92 0.0012 3.6 ## count ## [1] 19 ## [2] 10 ## [3] 17 ## [4] 10 ## [5] 11 根據計算結果，解讀模型的方法如下： 啤酒=&gt;尿布 Support: 一次交易中，包括規則內的物品的機率。買啤酒同時買尿布的機率。交集 Confidence: 包含左邊物品A的交易也會包含右邊物品B的條件機率。在買了啤酒的顧客中，有買尿布的比例。 Lift: 規則的信心比期望值高多少。（買了啤酒以後，有買尿布的機率）/（在所有顧客群中買尿布的機率） lift=1: items on the left and right are independent. 可用排序功能排序後，列出最有關連（confidence最高）的幾條規則 rules&lt;-sort(rules, by=&quot;confidence&quot;, decreasing=TRUE) #按照confidence排序 inspect(rules[1:5]) # Show the top 5 rules ## lhs rhs support confidence coverage lift count ## [1] {rice, ## sugar} =&gt; {whole milk} 0.0012 1 0.0012 3.9 12 ## [2] {canned fish, ## hygiene articles} =&gt; {whole milk} 0.0011 1 0.0011 3.9 11 ## [3] {root vegetables, ## butter, ## rice} =&gt; {whole milk} 0.0010 1 0.0010 3.9 10 ## [4] {root vegetables, ## whipped/sour cream, ## flour} =&gt; {whole milk} 0.0017 1 0.0017 3.9 17 ## [5] {butter, ## soft cheese, ## domestic eggs} =&gt; {whole milk} 0.0010 1 0.0010 3.9 10 特別針對某項商品（右側變數），像是：買了什麼東西的人，會買牛奶呢？ rulesR&lt;-apriori(data=Groceries, parameter=list(supp=0.001,conf = 0.08), appearance = list(default=&quot;lhs&quot;,rhs=&quot;whole milk&quot;), #設定右邊一定要是牛奶 control = list(verbose=F)) #不要顯示output rulesR&lt;-sort(rulesR, decreasing=TRUE,by=&quot;confidence&quot;) #按照confidence排序 inspect(rulesR[1:5]) # Show the top 5 rules ## lhs rhs support confidence coverage lift count ## [1] {rice, ## sugar} =&gt; {whole milk} 0.0012 1 0.0012 3.9 12 ## [2] {canned fish, ## hygiene articles} =&gt; {whole milk} 0.0011 1 0.0011 3.9 11 ## [3] {root vegetables, ## butter, ## rice} =&gt; {whole milk} 0.0010 1 0.0010 3.9 10 ## [4] {root vegetables, ## whipped/sour cream, ## flour} =&gt; {whole milk} 0.0017 1 0.0017 3.9 17 ## [5] {butter, ## soft cheese, ## domestic eggs} =&gt; {whole milk} 0.0010 1 0.0010 3.9 10 特別針對某項商品（左側變數），像是：買了牛奶的人，會買什麼呢？ rulesL&lt;-apriori(data=Groceries, parameter=list(supp=0.001,conf = 0.15,minlen=2), appearance = list(default=&quot;rhs&quot;,lhs=&quot;whole milk&quot;), #設定左邊一定要是牛奶 control = list(verbose=F)) #不要顯示output rulesL&lt;-sort(rulesL, decreasing=TRUE,by=&quot;confidence&quot;) #按照confidence排序 inspect(rulesL[1:5]) # Show the top 5 rules ## lhs rhs support confidence coverage lift count ## [1] {whole milk} =&gt; {other vegetables} 0.075 0.29 0.26 1.5 736 ## [2] {whole milk} =&gt; {rolls/buns} 0.057 0.22 0.26 1.2 557 ## [3] {whole milk} =&gt; {yogurt} 0.056 0.22 0.26 1.6 551 ## [4] {whole milk} =&gt; {root vegetables} 0.049 0.19 0.26 1.8 481 ## [5] {whole milk} =&gt; {tropical fruit} 0.042 0.17 0.26 1.6 416 規則視覺化 if (!require(&#39;arulesViz&#39;)){ install.packages(&quot;arulesViz&quot;); library(arulesViz) } #Mac-&gt;http://planspace.org/2013/01/17/fix-r-tcltk-dependency-problem-on-mac/ plot(rules,method=&quot;graph&quot;,interactive=TRUE,shading=NA) #會跑一陣子 10.6 Open Source Packages 10.6.1 Prophet Prophet 是 Facebook在2017年開放出來的時序性預測演算法，用來預測各類資料的時序變化，像是顧客造訪數、溫度、疾病發生率等等，以下是Prophet for R的安裝使用範例 C/C++ Tool R Tools on Windows Command Line Tools on OS X install.packages(&#39;prophet&#39;) R API library(prophet) library(dplyr) df &lt;- read.csv(&#39;https://raw.githubusercontent.com/facebookincubator/prophet/master/examples/example_wp_peyton_manning.csv&#39;) %&gt;% mutate(y = log(y)) m &lt;- prophet(df) future &lt;- make_future_dataframe(m, periods = 365) tail(future) forecast &lt;- predict(m, future) tail(forecast[c(&#39;ds&#39;, &#39;yhat&#39;, &#39;yhat_lower&#39;, &#39;yhat_upper&#39;)]) plot(m, forecast) prophet_plot_components(m, forecast) Prophet官網 10.6.2 TensorFlow Python 3.5.3 64 bit 網站 Windows x86-64 executable installer TensorFlow 1.0.1 網站 pip3 install –upgrade tensorflow pip3 install –upgrade tensorflow-gpu C/C++ Tool R Tools on Windows Command Line Tools on OS X tensorflow package for R 網站 devtools::install_github(&quot;rstudio/tensorflow&quot;) TensorFlow for R Locating TensorFlow (optional) Hello World library(tensorflow) sess = tf$Session() hello &lt;- tf$constant(&#39;Hello, TensorFlow!&#39;) sess$run(hello) 10.6.3 MXNet Amazon Install MXNet for R MXNet for R Tutorials MXNet for R install.packages(&quot;drat&quot;, repos=&quot;https://cran.rstudio.com&quot;) drat:::addRepo(&quot;dmlc&quot;) install.packages(&quot;mxnet&quot;) 10.7 模型驗證 在完成模型訓練後，為了驗證模型訓練的好不好，需要用一組獨立的測試資料，來做模型的驗證。所以，在訓練模型前，必須特別留意是否有保留一份獨立的資料，並確保在訓練模型時都不用到此獨立資料集。因此，資料集可分為以下兩種： 訓練組 Training set, Development set: 讓演算法學到知識 測試組 Test set, Validation set: 驗證學的怎麼樣 Training set和Test set通常會比例分配，如2/3的資料設為Training set，剩下的1/3做驗證Test set。以下圖的監督式學習流程圖為例，可以注意到綠色箭頭的資料集在訓練過程中從未被使用。 10.7.1 Regression 迴歸驗證 以NBA資料為例，首先先將資料讀入 #讀入SportsAnalytics package if (!require(&#39;SportsAnalytics&#39;)){ install.packages(&quot;SportsAnalytics&quot;) library(SportsAnalytics) } #擷取2015-2016年球季球員資料 NBA1516&lt;-fetch_NBAPlayerStatistics(&quot;15-16&quot;) NBA1516&lt;-NBA1516[complete.cases(NBA1516),] 以Training set來選看起來最好的模型 用Test set來驗證模型是不是真的很好 想像…..訓練出來題庫答得好的學生，寫到新題目不一定會寫！？ 訓練模型時，只能看Training set，用Training set來選一個最好的模型 訓練模型時，不能偷看Test set，才是真正的驗證 為分出訓練組與測試組，需使用隨機抽樣的方式 sample(1:10,3) # 從1到10，隨機取三個數字 ## [1] 8 3 4 sample(1:nrow(NBA1516),nrow(NBA1516)/3) #從第一行到最後一行，隨機取1/3行數 ## [1] 93 122 389 66 175 424 379 468 304 108 131 343 41 115 228 328 416 298 ## [19] 299 258 117 79 182 305 358 184 307 390 452 221 224 49 313 136 282 145 ## [37] 123 264 234 96 22 291 297 208 465 342 57 10 406 248 365 153 431 83 ## [55] 245 426 218 215 326 276 169 71 61 352 417 383 155 460 467 60 36 375 ## [73] 19 137 126 158 319 116 440 102 214 314 448 85 392 160 77 17 401 262 ## [91] 130 181 267 316 356 163 461 277 396 134 265 403 249 435 40 29 425 185 ## [109] 294 88 400 363 411 335 86 142 147 414 188 355 26 372 418 28 101 296 ## [127] 323 408 359 189 196 84 422 250 388 281 380 471 30 428 354 444 80 73 ## [145] 148 12 293 195 303 361 166 347 146 107 240 31 6 263 使用上述方法，選出1/3的元素位置，把NBA的資料分成Training 和 Test set NBA1516$Test&lt;-F #新增一個參數紀錄分組 #隨機取1/3當Test set NBA1516[sample(1:nrow(NBA1516),nrow(NBA1516)/3),&quot;Test&quot;]&lt;-T # Training set : Test set球員數 c(sum(NBA1516$Test==F),sum(NBA1516$Test==T)) ## [1] 317 158 並用訓練組的資料（NBA1516$Test==F），訓練一個多變數線性迴歸模型 fit&lt;-glm(TotalPoints~TotalMinutesPlayed+FieldGoalsAttempted+ Position+ThreesAttempted+FreeThrowsAttempted, data =NBA1516[NBA1516$Test==F,]) summary(fit)$coefficients ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 9.7517 7.8573 1.24 2.2e-01 ## TotalMinutesPlayed -0.0028 0.0078 -0.36 7.2e-01 ## FieldGoalsAttempted 0.9921 0.0234 42.36 1.7e-130 ## PositionPF -14.5514 8.3559 -1.74 8.3e-02 ## PositionPG -34.5378 9.1477 -3.78 1.9e-04 ## PositionSF -14.2217 9.2792 -1.53 1.3e-01 ## PositionSG -25.6675 9.3777 -2.74 6.6e-03 ## ThreesAttempted 0.1016 0.0315 3.23 1.4e-03 ## FreeThrowsAttempted 0.7903 0.0390 20.28 1.2e-58 逐步選擇模型 stepwise 後退學習：一開始先將所有參數加到模型裡，再一個一個拿掉 library(MASS) ##根據AIC，做逐步選擇, 預設倒退學習 direction = &quot;backward&quot; ##trace=FALSE: 不要顯示步驟 finalModel_B&lt;-stepAIC(fit,direction = &quot;backward&quot;,trace=FALSE) summary(finalModel_B)$coefficients ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 8.70 7.275 1.2 2.3e-01 ## FieldGoalsAttempted 0.99 0.017 56.6 4.3e-165 ## PositionPF -14.34 8.322 -1.7 8.6e-02 ## PositionPG -34.14 9.068 -3.8 2.0e-04 ## PositionSF -14.01 9.246 -1.5 1.3e-01 ## PositionSG -25.26 9.294 -2.7 6.9e-03 ## ThreesAttempted 0.10 0.031 3.2 1.4e-03 ## FreeThrowsAttempted 0.79 0.039 20.4 4.3e-59 逐步選擇模型 stepwise 往前學習：一開始先做一個沒有參數的模型，再把參數一個一個加進去 ##根據AIC，做逐步選擇, 往前學習 direction = &quot;forward&quot; finalModel_F&lt;-stepAIC(fit,direction = &quot;forward&quot;,trace=FALSE) summary(finalModel_F)$coefficients ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 9.7517 7.8573 1.24 2.2e-01 ## TotalMinutesPlayed -0.0028 0.0078 -0.36 7.2e-01 ## FieldGoalsAttempted 0.9921 0.0234 42.36 1.7e-130 ## PositionPF -14.5514 8.3559 -1.74 8.3e-02 ## PositionPG -34.5378 9.1477 -3.78 1.9e-04 ## PositionSF -14.2217 9.2792 -1.53 1.3e-01 ## PositionSG -25.6675 9.3777 -2.74 6.6e-03 ## ThreesAttempted 0.1016 0.0315 3.23 1.4e-03 ## FreeThrowsAttempted 0.7903 0.0390 20.28 1.2e-58 逐步選擇模型 stepwise 雙向學習：參數加加減減 ##根據AIC，做逐步選擇, 雙向學習 direction = &quot;both&quot; finalModel_Both&lt;-stepAIC(fit,direction = &quot;both&quot;,trace=FALSE) summary(finalModel_Both)$coefficients ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 8.70 7.275 1.2 2.3e-01 ## FieldGoalsAttempted 0.99 0.017 56.6 4.3e-165 ## PositionPF -14.34 8.322 -1.7 8.6e-02 ## PositionPG -34.14 9.068 -3.8 2.0e-04 ## PositionSF -14.01 9.246 -1.5 1.3e-01 ## PositionSG -25.26 9.294 -2.7 6.9e-03 ## ThreesAttempted 0.10 0.031 3.2 1.4e-03 ## FreeThrowsAttempted 0.79 0.039 20.4 4.3e-59 用Test set來評估模型好不好，使用predict函數，將測試組資料放入預測模型中，預測測試組的結果 predictPoint&lt;-predict(finalModel_Both, #Test==T, test data newdata = NBA1516[NBA1516$Test==T,]) cor(x=predictPoint,y=NBA1516[NBA1516$Test==T,]$TotalPoints) #相關係數 ## [1] 1 plot(x=predictPoint,y=NBA1516[NBA1516$Test==T,]$TotalPoints) 10.7.2 Logistic Regression 邏輯迴歸驗證 首先，先把入學資料分成Training 和 Test set。這邊要特別留意，當答案有正反兩面時，Level 2 要放正面答案–&gt;有病/錄取… mydata &lt;- read.csv(&quot;https://raw.githubusercontent.com/CGUIM-BigDataAnalysis/BigDataCGUIM/master/binary.csv&quot;) mydata$admit &lt;- factor(mydata$admit) # 類別變項要轉為factor mydata$rank &lt;- factor(mydata$rank) # 類別變項要轉為factor mydata$Test&lt;-F #新增一個參數紀錄分組 mydata[sample(1:nrow(mydata),nrow(mydata)/3),&quot;Test&quot;]&lt;-T #隨機取1/3當Test set c(sum(mydata$Test==F),sum(mydata$Test==T)) # Training set : Test set學生數 ## [1] 267 133 #修改一下factor的level: 改成Level 2為錄取，1為不錄取--&gt;Level 2 要放正面答案 mydata$admit&lt;-factor(mydata$admit,levels=c(0,1)) 逐步選擇最好的模型 # GRE:某考試成績, GPA:在校平均成績, rank:學校聲望 mylogit &lt;- glm(admit ~ gre + gpa + rank, data = mydata[mydata$Test==F,], family = &quot;binomial&quot;) finalFit&lt;-stepAIC(mylogit,direction = &quot;both&quot;,trace=FALSE) # 雙向逐步選擇模型 summary(finalFit) ## ## Call: ## glm(formula = admit ~ gpa + rank, family = &quot;binomial&quot;, data = mydata[mydata$Test == ## F, ]) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.578 -0.893 -0.632 1.085 2.146 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -4.022 1.437 -2.80 0.00514 ** ## gpa 1.232 0.400 3.08 0.00206 ** ## rank2 -0.641 0.387 -1.66 0.09783 . ## rank3 -1.440 0.427 -3.37 0.00074 *** ## rank4 -1.589 0.516 -3.08 0.00207 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 339.9 on 266 degrees of freedom ## Residual deviance: 309.8 on 262 degrees of freedom ## AIC: 319.8 ## ## Number of Fisher Scoring iterations: 4 用預測組預測新學生可不可以錄取，並驗證答案 AdmitProb&lt;-predict(finalFit, # 用Training set做的模型 newdata = mydata[mydata$Test==T,], #Test==T, test data type=&quot;response&quot;) #結果為每個人被錄取的機率 head(AdmitProb) ## 1 2 10 11 13 14 ## 0.27 0.28 0.54 0.34 0.71 0.30 table(AdmitProb&gt;0.5,mydata[mydata$Test==T,]$admit) # row,column ## ## 0 1 ## FALSE 84 29 ## TRUE 11 9 當答案是二元時：效能指標 Sensitivity 敏感性 Specificity 特異性 Positive Predictive Value (PPV) 陽性預測值 Negative Predictive Value (NPV) 陰性預測值 名詞解釋 TP: 有病且預測也有病 TN: 沒病且預測也沒病 FP: 沒病但是預測有病 FN: 有病但預測沒病 當答案是二元時：效能指標公式 Sensitivity 敏感性：所有真的有病的人，被預測有病的比例 Specificity 特異性：所有真的沒病的人，被預測沒病的比例 Positive Predictive Value (PPV) 陽性預測值：所有被預測有病的人，真的有病的比例 Negative Predictive Value (NPV) 陰性預測值：所有被預測沒病的人，真的沒病的比例 回想一下剛剛的驗證結果 table(AdmitProb&gt;0.5,mydata[mydata$Test==T,]$admit) # row,column ## ## 0 1 ## FALSE 84 29 ## TRUE 11 9 計算預測效能參數 AdmitProb&lt;-predict(finalFit, newdata = mydata[mydata$Test==T,], #Test==T, test data type=&quot;response&quot;) #結果為每個人被錄取的機率 AdmitAns&lt;-factor(ifelse(AdmitProb&gt;0.5,1,0),levels=c(0,1)) str(AdmitAns) ## Factor w/ 2 levels &quot;0&quot;,&quot;1&quot;: 1 1 2 1 2 1 1 1 1 1 ... ## - attr(*, &quot;names&quot;)= chr [1:133] &quot;1&quot; &quot;2&quot; &quot;10&quot; &quot;11&quot; ... 計算預測效能參數 library(caret) # install.packages(&quot;caret&quot;) #計算參數的packages sensitivity(AdmitAns,mydata[mydata$Test==T,]$admit,positive = &quot;1&quot;) ## [1] 0.24 specificity(AdmitAns,mydata[mydata$Test==T,]$admit,negative = &quot;0&quot;) ## [1] 0.88 posPredValue(AdmitAns,mydata[mydata$Test==T,]$admit,positive = &quot;1&quot;) ## [1] 0.45 negPredValue(AdmitAns,mydata[mydata$Test==T,]$admit,negative = &quot;0&quot;) ## [1] 0.74 10.7.3 Decision Trees 決策樹驗證 阻攻/籃板/三分/助攻/抄截判斷位置-訓練 if (!require(&#39;rpart&#39;)){ install.packages(&quot;rpart&quot;); library(rpart) } DT&lt;-rpart(Position~Blocks+TotalRebounds+ThreesMade+Assists+Steals, data=NBA1516[NBA1516$Test==F,]) #訓練組 Training set #控球後衛（PG）、得分後衛（SG）、小前鋒（SF）、大前鋒（PF）和中鋒（C） DT ## n= 317 ## ## node), split, n, loss, yval, (yprob) ## * denotes terminal node ## ## 1) root 317 240 PF (0.16 0.23 0.21 0.18 0.22) ## 2) ThreesMade&lt; 6.5 121 76 C (0.37 0.36 0.091 0.091 0.091) ## 4) Blocks&gt;=3.5 78 37 C (0.53 0.44 0.013 0.026 0) ## 8) Blocks&gt;=17 55 20 C (0.64 0.35 0.018 0 0) ## 16) Assists&lt; 40 16 1 C (0.94 0.063 0 0 0) * ## 17) Assists&gt;=40 39 19 C (0.51 0.46 0.026 0 0) ## 34) Blocks&gt;=88 12 1 C (0.92 0.083 0 0 0) * ## 35) Blocks&lt; 88 27 10 PF (0.33 0.63 0.037 0 0) * ## 9) Blocks&lt; 17 23 8 PF (0.26 0.65 0 0.087 0) * ## 5) Blocks&lt; 3.5 43 32 SG (0.093 0.21 0.23 0.21 0.26) ## 10) Assists&lt; 0.5 9 4 SF (0 0.33 0.11 0.56 0) * ## 11) Assists&gt;=0.5 34 23 SG (0.12 0.18 0.26 0.12 0.32) ## 22) ThreesMade&lt; 0.5 13 8 PG (0.31 0.23 0.38 0 0.077) * ## 23) ThreesMade&gt;=0.5 21 11 SG (0 0.14 0.19 0.19 0.48) * ## 3) ThreesMade&gt;=6.5 196 140 SG (0.031 0.15 0.29 0.23 0.3) ## 6) Assists&gt;=1.4e+02 75 32 PG (0.027 0.04 0.57 0.15 0.21) ## 12) TotalRebounds&lt; 2.8e+02 48 9 PG (0 0 0.81 0 0.19) * ## 13) TotalRebounds&gt;=2.8e+02 27 16 SF (0.074 0.11 0.15 0.41 0.26) * ## 7) Assists&lt; 1.4e+02 121 79 SG (0.033 0.22 0.11 0.29 0.35) ## 14) TotalRebounds&gt;=2.9e+02 29 13 PF (0.069 0.55 0 0.34 0.034) ## 28) Steals&lt; 54 16 3 PF (0.12 0.81 0 0.062 0) * ## 29) Steals&gt;=54 13 4 SF (0 0.23 0 0.69 0.077) * ## 15) TotalRebounds&lt; 2.9e+02 92 51 SG (0.022 0.12 0.14 0.27 0.45) ## 30) ThreesMade&lt; 48 62 41 SG (0.032 0.15 0.18 0.31 0.34) ## 60) TotalRebounds&gt;=1.2e+02 21 9 SF (0.048 0.24 0 0.57 0.14) ## 120) Steals&lt; 24 8 3 PF (0.12 0.62 0 0.12 0.12) * ## 121) Steals&gt;=24 13 2 SF (0 0 0 0.85 0.15) * ## 61) TotalRebounds&lt; 1.2e+02 41 23 SG (0.024 0.098 0.27 0.17 0.44) ## 122) Assists&gt;=43 14 5 PG (0 0.071 0.64 0 0.29) * ## 123) Assists&lt; 43 27 13 SG (0.037 0.11 0.074 0.26 0.52) * ## 31) ThreesMade&gt;=48 30 10 SG (0 0.067 0.067 0.2 0.67) * 阻攻/籃板/三分/助攻/抄截判斷位置-訓練 預設的plot()真的太難用，改用rpart.plot package的prp() if (!require(&#39;rpart.plot&#39;)){ install.packages(&quot;rpart.plot&quot;); library(rpart.plot) } prp(DT) # 把決策樹畫出來 阻攻/籃板/三分/助攻/抄截判斷位置-訓練 prp(DT) 有批球員沒寫守備位置？–預測 posPred&lt;-predict(DT,newdata= NBA1516[NBA1516$Test==T,]) #Test==T, test data # 預設為class probabilities, type = &quot;prob&quot; head(posPred) ## C PF PG SF SG ## 4 0.000 0.00 0.812 0.000 0.188 ## 10 0.000 0.23 0.000 0.692 0.077 ## 15 0.037 0.11 0.074 0.259 0.519 ## 22 0.261 0.65 0.000 0.087 0.000 ## 30 0.125 0.62 0.000 0.125 0.125 ## 36 0.074 0.11 0.148 0.407 0.259 有個人沒寫守備位置–對答案 result&lt;-cbind(round(posPred,digits = 2), NBA1516[NBA1516$Test==T,]$Name, as.character(NBA1516[NBA1516$Test==T,]$Position)) head(result) ## C PF PG SF SG ## 4 &quot;0&quot; &quot;0&quot; &quot;0.81&quot; &quot;0&quot; &quot;0.19&quot; &quot;Arron Afflalo&quot; &quot;SG&quot; ## 10 &quot;0&quot; &quot;0.23&quot; &quot;0&quot; &quot;0.69&quot; &quot;0.08&quot; &quot;Tony Allen&quot; &quot;SG&quot; ## 15 &quot;0.04&quot; &quot;0.11&quot; &quot;0.07&quot; &quot;0.26&quot; &quot;0.52&quot; &quot;James Anderson&quot; &quot;SG&quot; ## 22 &quot;0.26&quot; &quot;0.65&quot; &quot;0&quot; &quot;0.09&quot; &quot;0&quot; &quot;Joel Anthony&quot; &quot;C&quot; ## 30 &quot;0.12&quot; &quot;0.62&quot; &quot;0&quot; &quot;0.12&quot; &quot;0.12&quot; &quot;Luke Babbitt&quot; &quot;SF&quot; ## 36 &quot;0.07&quot; &quot;0.11&quot; &quot;0.15&quot; &quot;0.41&quot; &quot;0.26&quot; &quot;Matt Barnes&quot; &quot;SF&quot; 有個人沒寫守備位置–預測-2 posPredC&lt;-predict(DT,newdata= NBA1516[NBA1516$Test==T,],type = &quot;class&quot;) # type = &quot;class&quot; 直接預測類別 head(posPredC) ## 4 10 15 22 30 36 ## PG SF SG PF PF SF ## Levels: C PF PG SF SG 有個人沒寫守備位置–對答案-2 resultC&lt;-cbind(as.character(posPredC),NBA1516[NBA1516$Test==T,]$Name, as.character(NBA1516[NBA1516$Test==T,]$Position)) head(resultC) ## [,1] [,2] [,3] ## [1,] &quot;PG&quot; &quot;Arron Afflalo&quot; &quot;SG&quot; ## [2,] &quot;SF&quot; &quot;Tony Allen&quot; &quot;SG&quot; ## [3,] &quot;SG&quot; &quot;James Anderson&quot; &quot;SG&quot; ## [4,] &quot;PF&quot; &quot;Joel Anthony&quot; &quot;C&quot; ## [5,] &quot;PF&quot; &quot;Luke Babbitt&quot; &quot;SF&quot; ## [6,] &quot;SF&quot; &quot;Matt Barnes&quot; &quot;SF&quot; 10.8 Case Study 完整的模型建立步驟範例： 標題：以聲波撞擊礦石的回聲預測礦石是否為礦物 以Sonar, Mines vs. Rocks為例 步驟1.1:讀資料 #install.packages(&quot;mlbench&quot;) # 此package內有很多dataset可練習 library(mlbench) data(Sonar) str(Sonar) #看一下資料型別，有沒有缺值，類別變項是不是factor ## &#39;data.frame&#39;: 208 obs. of 61 variables: ## $ V1 : num 0.02 0.0453 0.0262 0.01 0.0762 0.0286 0.0317 0.0519 0.0223 0.0164 ... ## $ V2 : num 0.0371 0.0523 0.0582 0.0171 0.0666 0.0453 0.0956 0.0548 0.0375 0.0173 ... ## $ V3 : num 0.0428 0.0843 0.1099 0.0623 0.0481 ... ## $ V4 : num 0.0207 0.0689 0.1083 0.0205 0.0394 ... ## $ V5 : num 0.0954 0.1183 0.0974 0.0205 0.059 ... ## $ V6 : num 0.0986 0.2583 0.228 0.0368 0.0649 ... ## $ V7 : num 0.154 0.216 0.243 0.11 0.121 ... ## $ V8 : num 0.16 0.348 0.377 0.128 0.247 ... ## $ V9 : num 0.3109 0.3337 0.5598 0.0598 0.3564 ... ## $ V10 : num 0.211 0.287 0.619 0.126 0.446 ... ## $ V11 : num 0.1609 0.4918 0.6333 0.0881 0.4152 ... ## $ V12 : num 0.158 0.655 0.706 0.199 0.395 ... ## $ V13 : num 0.2238 0.6919 0.5544 0.0184 0.4256 ... ## $ V14 : num 0.0645 0.7797 0.532 0.2261 0.4135 ... ## $ V15 : num 0.066 0.746 0.648 0.173 0.453 ... ## $ V16 : num 0.227 0.944 0.693 0.213 0.533 ... ## $ V17 : num 0.31 1 0.6759 0.0693 0.7306 ... ## $ V18 : num 0.3 0.887 0.755 0.228 0.619 ... ## $ V19 : num 0.508 0.802 0.893 0.406 0.203 ... ## $ V20 : num 0.48 0.782 0.862 0.397 0.464 ... ## $ V21 : num 0.578 0.521 0.797 0.274 0.415 ... ## $ V22 : num 0.507 0.405 0.674 0.369 0.429 ... ## $ V23 : num 0.433 0.396 0.429 0.556 0.573 ... ## $ V24 : num 0.555 0.391 0.365 0.485 0.54 ... ## $ V25 : num 0.671 0.325 0.533 0.314 0.316 ... ## $ V26 : num 0.641 0.32 0.241 0.533 0.229 ... ## $ V27 : num 0.71 0.327 0.507 0.526 0.7 ... ## $ V28 : num 0.808 0.277 0.853 0.252 1 ... ## $ V29 : num 0.679 0.442 0.604 0.209 0.726 ... ## $ V30 : num 0.386 0.203 0.851 0.356 0.472 ... ## $ V31 : num 0.131 0.379 0.851 0.626 0.51 ... ## $ V32 : num 0.26 0.295 0.504 0.734 0.546 ... ## $ V33 : num 0.512 0.198 0.186 0.612 0.288 ... ## $ V34 : num 0.7547 0.2341 0.2709 0.3497 0.0981 ... ## $ V35 : num 0.854 0.131 0.423 0.395 0.195 ... ## $ V36 : num 0.851 0.418 0.304 0.301 0.418 ... ## $ V37 : num 0.669 0.384 0.612 0.541 0.46 ... ## $ V38 : num 0.61 0.106 0.676 0.881 0.322 ... ## $ V39 : num 0.494 0.184 0.537 0.986 0.283 ... ## $ V40 : num 0.274 0.197 0.472 0.917 0.243 ... ## $ V41 : num 0.051 0.167 0.465 0.612 0.198 ... ## $ V42 : num 0.2834 0.0583 0.2587 0.5006 0.2444 ... ## $ V43 : num 0.282 0.14 0.213 0.321 0.185 ... ## $ V44 : num 0.4256 0.1628 0.2222 0.3202 0.0841 ... ## $ V45 : num 0.2641 0.0621 0.2111 0.4295 0.0692 ... ## $ V46 : num 0.1386 0.0203 0.0176 0.3654 0.0528 ... ## $ V47 : num 0.1051 0.053 0.1348 0.2655 0.0357 ... ## $ V48 : num 0.1343 0.0742 0.0744 0.1576 0.0085 ... ## $ V49 : num 0.0383 0.0409 0.013 0.0681 0.023 0.0264 0.0507 0.0285 0.0777 0.0092 ... ## $ V50 : num 0.0324 0.0061 0.0106 0.0294 0.0046 0.0081 0.0159 0.0178 0.0439 0.0198 ... ## $ V51 : num 0.0232 0.0125 0.0033 0.0241 0.0156 0.0104 0.0195 0.0052 0.0061 0.0118 ... ## $ V52 : num 0.0027 0.0084 0.0232 0.0121 0.0031 0.0045 0.0201 0.0081 0.0145 0.009 ... ## $ V53 : num 0.0065 0.0089 0.0166 0.0036 0.0054 0.0014 0.0248 0.012 0.0128 0.0223 ... ## $ V54 : num 0.0159 0.0048 0.0095 0.015 0.0105 0.0038 0.0131 0.0045 0.0145 0.0179 ... ## $ V55 : num 0.0072 0.0094 0.018 0.0085 0.011 0.0013 0.007 0.0121 0.0058 0.0084 ... ## $ V56 : num 0.0167 0.0191 0.0244 0.0073 0.0015 0.0089 0.0138 0.0097 0.0049 0.0068 ... ## $ V57 : num 0.018 0.014 0.0316 0.005 0.0072 0.0057 0.0092 0.0085 0.0065 0.0032 ... ## $ V58 : num 0.0084 0.0049 0.0164 0.0044 0.0048 0.0027 0.0143 0.0047 0.0093 0.0035 ... ## $ V59 : num 0.009 0.0052 0.0095 0.004 0.0107 0.0051 0.0036 0.0048 0.0059 0.0056 ... ## $ V60 : num 0.0032 0.0044 0.0078 0.0117 0.0094 0.0062 0.0103 0.0053 0.0022 0.004 ... ## $ Class: Factor w/ 2 levels &quot;M&quot;,&quot;R&quot;: 2 2 2 2 2 2 2 2 2 2 ... 在建立模型之前…別忘了基本的資料分析，使用探索性分析 Exploratory data analysis，看看資料長怎麼樣，要是有一個參數可以完美的把礦物跟石頭分開，那就不用麻煩建模了… 探索性分析 Exploratory data analysis library(ggplot2);library(reshape2) #install.packages(c(&quot;ggplot2&quot;,&quot;reshape2&quot;)) Sonar.m&lt;-melt(Sonar,id.vars = c(&quot;Class&quot;)) ggplot(Sonar.m)+geom_boxplot(aes(x=Class,y=value))+ facet_wrap(~variable, nrow=5,scales = &quot;free_y&quot;) #圖片太小了 步驟1.2: 資料前處理 缺值？ 沒有缺值，不需要處理 答案種類？ 類別變項叫Class，M: mine礦–&gt;+, R: rock–&gt;-，不需要處理 類別變項的型別是不是factor？ 是，不需要處理 有沒有無關的參數？ 沒有無關的參數，不需要處理 步驟2:分成訓練組與測試組 該怎麼分可以自己決定，1/3，1/5…都可以 Sonar$Test&lt;-F #新增一個參數紀錄分組 #隨機取1/3當Test set Sonar[sample(1:nrow(Sonar),nrow(Sonar)/3),&quot;Test&quot;]&lt;-T # 看一下 Training set : Test set 案例數 c(sum(Sonar$Test==F),sum(Sonar$Test==T)) ## [1] 139 69 步驟3:訓練模型 注意只能用訓練組的資料，Test參數==F，忘記可以看前面範例 數值自變項X很多，先用迴歸好了～ 要解釋一下模型 fit&lt;-glm(Class~., Sonar[Sonar$Test==F,],family=&quot;binomial&quot;) finalFit&lt;-stepAIC(fit,direction = &quot;both&quot;,trace = F) summary(finalFit)$coefficients ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 8637 253120 0.034 0.97 ## V1 -27931 828078 -0.034 0.97 ## V4 -29704 865613 -0.034 0.97 ## V7 19584 569191 0.034 0.97 ## V12 -3853 115443 -0.033 0.97 ## V15 -4393 126979 -0.035 0.97 ## V16 9634 278340 0.035 0.97 ## V18 -6121 177507 -0.034 0.97 ## V24 -6950 204480 -0.034 0.97 ## V29 4569 132801 0.034 0.97 ## V30 -13257 385129 -0.034 0.97 ## V31 10863 313890 0.035 0.97 ## V35 -7224 207966 -0.035 0.97 ## V36 13153 378812 0.035 0.97 ## V39 -9482 282208 -0.034 0.97 ## V40 10567 313200 0.034 0.97 ## V42 -5664 167265 -0.034 0.97 ## V44 -11255 322840 -0.035 0.97 ## V48 -25776 746398 -0.035 0.97 ## V56 159309 4633625 0.034 0.97 ## V58 -179362 5140624 -0.035 0.97 步驟4.1:用測試組驗證模型-預測 MinePred&lt;-predict(finalFit,newdata = Sonar[Sonar$Test==T,]) MineAns&lt;-ifelse(MinePred&gt;0.5,&quot;R&quot;,&quot;M&quot;) #&gt;0.5: Level 2 MineAns&lt;-factor(MineAns,levels = c(&quot;M&quot;,&quot;R&quot;)) MineAns ## 2 5 6 8 14 17 22 24 27 32 34 37 39 40 43 45 48 51 53 55 ## R R R M R R M R M R R R R R R M M R R M ## 56 60 68 74 75 80 83 84 94 95 103 105 109 112 113 115 123 126 128 130 ## M R R M R M M M M R M M M M M M M M M M ## 131 132 133 135 143 144 150 151 154 158 160 161 162 163 166 168 169 175 179 183 ## M M R R M M M R M M M M M M M M M M R M ## 184 188 190 192 199 200 201 202 203 ## M M R M M M M M M ## Levels: M R 步驟4.2:用測試組驗證模型-效能 library(caret) # install.packages(&quot;caret&quot;) #計算參數的packages sensitivity(MineAns,Sonar[Sonar$Test==T,]$Class) ## [1] 0.87 specificity(MineAns,Sonar[Sonar$Test==T,]$Class) ## [1] 0.6 posPredValue(MineAns,Sonar[Sonar$Test==T,]$Class) ## [1] 0.74 negPredValue(MineAns,Sonar[Sonar$Test==T,]$Class) ## [1] 0.78 解釋範例 - 資料說明 此資料來源為UCI Machine Learning Repository。 記載礦物與石頭接受各個不同角度的聲波撞擊後，接收到的回聲數值，一共有60個參數，代表使用一特別角度的聲波撞擊礦石所得回聲。另外，分類結果為二元分類，包括礦物 (M) 與石頭 (R) 。 解釋範例 - 模型說明 使用聲波在不同角度撞擊礦石所得到的回聲資料，以邏輯迴歸建立模型預測礦石是否為礦物，經最佳化後，模型使用參數為V1 + V2 + V3 + V4 + V7 + V11 + V12 + V13 + V17 + V18 + V22 + V24 + V25 + V26 + V30 + V31 + V32 + V38 + V39 + V48 + V50 + V52 + V53 + V58 + V59，共25個參數，各參數代表從一特別角度所得的礦石回聲 解釋範例 - 預測效能說明 使用聲波在不同角度撞擊礦石所得到的回聲資料，以邏輯迴歸模型預測礦石是否為礦物，可得敏感度97%，特異性89%，陽性預測率89%，陰性預測率97%。 10.9 參考資料 台大資工林軒田教授： Machine Learning Foundations Machine Learning Techniques Market Basket Analysis with R Deep Learning in R References "],
["big.html", "11 從小數據到大數據分析 11.1 R + Hadoop 11.2 RHadoop安裝測試流程 (Cloudera) 11.3 RHadoop MapReduce: easy word count 11.4 R + Spark", " 11 從小數據到大數據分析 11.1 R + Hadoop 11.2 RHadoop安裝測試流程 (Cloudera) 安裝與測試日期2016/05/12 11.2.1 系統/軟體版本資訊 Cloudera Hadoop Platform: CDH-5.4.5 下載 R for Linux 3.3.0 安裝說明 RStudio Server 下載 RHadoop (latest version on May 12, 2016) 下載 ravro-1.0.3 plyrmr-0.6.0 rmr-3.3.1 rhdfs-1.0.8 rhbase-1.2.1 11.2.2 參考資料 RHadoop安裝說明文件 RHadoop安裝步驟 Setting persistent environment variable in CentOS 7 issue How to resolve “Permission denied” errors in CDH 11.2.3 安裝步驟 下載Cloudera CDH QuickStart VM Cloudera VM 安裝R 安裝說明 安裝RHadoop RHadoop安裝步驟 安裝RStudio Server 說明 11.2.3.1 Cloudera CDH QuickStart VM Cloudera CDH QuickStart VM是由Cloudera提供的虛擬機器，內涵Linux系統與預載多項Hadoop相關服務，適合想了解Hadoop運作的初學者。 下載VM後，用Virtural Box 開啟即可。 Cloudera CDH QuickStart VM下載處 Virtural Box下載處 以下安裝步驟都在Cloudera CDH QuickStart VM內進行 11.2.3.2 安裝R Cloudera CDH用的Linux作業系統是CentOS 依照安裝說明，需要先安裝Extra Packages for Enterprise Linux (EPEL)，但系統內有預載，所以可以不用按照說明重新下載安裝，直接執行sudo yum install epel-release指令即可 步驟：安裝最新EPRL，更新yum，安裝R。打開Terminal輸入以下指令。 sudo yum install epel-release sudo yum update sudo yum install R 11.2.3.3 安裝RHadoop-1 先進行環境設定 設定HADOOP_CMD與HADOOP_STREAMING兩項環境參數，路徑可能會不同（尤其是HADOOP_STREAMING） 尋找HADOOP_STREAMING路徑方法 find / -name hadoop-streaming-*.jar 設定HADOOP_CMD與HADOOP_STREAMING兩項環境參數，路徑記得換成自己的 echo export HADOOP_CMD=&quot;/usr/bin/hadoop&quot;&gt;/etc/profile.d/hadoopenv.sh echo export HADOOP_STREAMING= &quot;/opt/cloudera/parcels/CDH-5.4.5-1.cdh5.4.5.p0.7/lib/hadoop-mapreduce/ hadoop-streaming-2.6.0-cdh5.4.5.jar&quot; &gt; /etc/profile.d/hadoopenv.sh chmod 0755 /etc/profile.d/hadoopenv.sh 11.2.3.4 安裝RHadoop-2 rmr2 每個Node都要裝 安裝前先至說明檔看需要先安裝哪些其他的packages，Depends 和 Imports 所列的packages都要裝 以下為安裝packages的程式碼，在R內執行（在Terminal輸入R，就能進入R軟體） install.packages(c(&quot;methods&quot;,&quot;Rcpp&quot;, &quot;RJSONIO&quot;, &quot;digest&quot;, &quot;functional&quot;, &quot;reshape2&quot;,&quot;stringr&quot;, &quot;plyr&quot;, &quot;caTools&quot;,&quot;quickcheck&quot;,&quot;testthat&quot;), dependencies=TRUE, repos=&#39;http://cran.rstudio.com/&#39;) 使用q()指令，跳出R軟體 下載rmr2 安裝（請將rmr2_2.3.0.tar.gz替換成剛剛下載的安裝檔路徑） sudo R CMD INSTALL rmr2_2.3.0.tar.gz 11.2.3.5 安裝RHadoop-3 rhdfs 只要裝在會跑R的那個Node 在裝之前，先Check是否有安裝JDK （測試JDK 1.8.0_91沒問題） Check環境變數JAVA_HOME是否有設好 echo $JAVA_HOME 若什麼都沒有回傳，先設定環境變數（將/usr/java/jdk1.8.0_91換成自己的路徑） echo export JAVA_HOME=&quot;/usr/java/jdk1.8.0_91&quot;&gt;/etc/profile.d/jdkenv.sh 為了讓R可以跑JAVA，在Terminal輸入 R CMD javareconf 然後進到R程式（在Terminal輸入R，就能進入R軟體），安裝rJava package install.packages(&quot;rJava&quot;,dependencies=TRUE, repos=&#39;http://cran.rstudio.com/&#39;){target=&quot;_blank&quot;} 最後跳出R程式，下載rhdfs，安裝rhdfs 將/usr/bin/hadoop換成自己的HADOOP_CMD路徑 rhdfs_1.0.8.tar.gz換成下載的安裝檔路徑） sudo HADOOP_CMD=/usr/bin/hadoop R CMD INSTALL rhdfs_1.0.8.tar.gz 11.2.4 測試前，先解決權限問題 預設hdfs的存取權限不足，所以要打開 將user01改為自己的使用者名稱 sudo -u hdfs hadoop fs -mkdir /user/user01 sudo -u hdfs hadoop fs -chown user01 /user/user01 11.2.5 測試 進入R測試以下程式碼是否能執行 Sys.setenv(HADOOP_CMD=&quot;/usr/bin/hadoop&quot;) Sys.setenv(HADOOP_STREAMING=&quot;/opt/cloudera/parcels/CDH-5.4.5-1.cdh5.4.5.p0.7/lib/hadoop-mapreduce/hadoop-streaming-2.6.0-cdh5.4.5.jar&quot;) library(rmr2) #test mapreduce small.ints = to.dfs(1:100) out&lt;-mapreduce( input = small.ints, map = function(., v) cbind(v, v^2)) head(from.dfs(out)) 11.2.6 安裝RStudio Server 官方下載與安裝說明 在Terminal執行以下程式碼 檔案連結https://download2.rstudio.org/rstudio-server-rhel-0.99.896-x86_64.rpm可能有最新版，請Check官網 wget https://download2.rstudio.org/rstudio-server-rhel-0.99.896-x86_64.rpm sudo yum install --nogpgcheck rstudio-server-rhel-0.99.896-x86_64.rpm 打開瀏覽器，輸入http://localhost:8787/，就能進入RStudio Server了！ 測完收工～ 11.3 RHadoop MapReduce: easy word count Debate&lt;-readLines(&quot;https://raw.githubusercontent.com/CGUIM-BigDataAnalysis/BigDataCGUIM/master/104/RepDebateMiami.txt&quot;) DebateSplit&lt;-unlist(strsplit(tolower(Debate),split = &#39; |\\\\.|\\\\,|\\\\?&#39;)) #table(DebateSplit) DebateSplitDFS = to.dfs(DebateSplit) result = mapreduce( input = DebateSplitDFS, map = function(.,v) keyval(v, 1), reduce = function(k,vv) keyval(k, sum(vv))) head(result) 11.4 R + Spark sparklyr SparkR Supports dplyr, Spark ML and H2O Distributed on CRAN Easy to install Extensible 測試環境 R version 3.3.2 (2016-10-31) Platform: x86_64-w64-mingw32/x64 (64-bit) Running under: Windows &gt;= 8 x64 (build 9200) sparklyr_0.5.3-9002 install.packages(&quot;sparklyr&quot;) #devtools::install_github(&quot;rstudio/sparklyr&quot;) library(sparklyr) spark_install(version = &quot;2.1.0&quot;) #Sys.setenv(SPARK_HOME=&quot;C:/Users/yjtseng/AppData/Local/rstudio/spark/Cache/spark-2.0.1-bin-hadoop2.7&quot;) #Sys.setenv(HADOOP_HOME=&quot;C:\\\\Program Files\\\\RStudio\\\\bin\\\\winutils\\\\x64\\\\&quot;) library(sparklyr) library(dplyr) sc &lt;- spark_connect(master = &quot;local&quot;, version = &quot;2.1.0&quot;) install.packages(c(&quot;nycflights13&quot;, &quot;Lahman&quot;)) iris_tbl &lt;- copy_to(sc, iris) flights_tbl &lt;- copy_to(sc, nycflights13::flights, &quot;flights&quot;) batting_tbl &lt;- copy_to(sc, Lahman::Batting, &quot;batting&quot;) src_tbls(sc) flights_tbl %&gt;% filter(dep_delay == 2) Source: query [6,233 x 19] Database: spark connection master=local[8] app=sparklyr local=TRUE year month day dep_time sched_dep_time dep_delay arr_time sched_arr_time arr_delay &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; &lt;int&gt; &lt;int&gt; &lt;dbl&gt; 1 2013 1 1 517 515 2 830 819 11 2 2013 1 1 542 540 2 923 850 33 3 2013 1 1 702 700 2 1058 1014 44 4 2013 1 1 715 713 2 911 850 21 5 2013 1 1 752 750 2 1025 1029 -4 6 2013 1 1 917 915 2 1206 1211 -5 7 2013 1 1 932 930 2 1219 1225 -6 8 2013 1 1 1028 1026 2 1350 1339 11 9 2013 1 1 1042 1040 2 1325 1326 -1 10 2013 1 1 1231 1229 2 1523 1529 -6 # ... with 6,223 more rows, and 10 more variables: carrier &lt;chr&gt;, flight &lt;int&gt;, # tailnum &lt;chr&gt;, origin &lt;chr&gt;, dest &lt;chr&gt;, air_time &lt;dbl&gt;, distance &lt;dbl&gt;, hour &lt;dbl&gt;, # minute &lt;dbl&gt;, time_hour &lt;dbl&gt; spark_disconnect(sc) 在RStudio中有整合Spark連線功能，右上角的Spark頁籤可供使用者開啟特定版本的Spark connections，除此之外，也可使用Spark頁籤瀏覽在Spark中的表格結構與資料的前1000列。 參考資料 http://spark.rstudio.com/ https://shiring.github.io/machine_learning/2017/02/19/food_spark "],
["install.html", "12 軟體安裝介紹 12.1 R安裝 12.2 RStudio安裝 12.3 RStudio使用簡介", " 12 軟體安裝介紹 本章節將介紹R與RStudio的安裝與基本使用方式 12.1 R安裝 R語言是一種自由軟體程式語言，主要用於資料分析與統計運算，2000年時終於發表R 1.0.0，有關R語言的發展歷史可參考維基百科。 安裝步驟如下: Step 1. 從R的官網下載安裝檔 進入R官網 https://www.r-project.org/ 選擇Download下方的CRAN連結 進入CRAN子網頁後，請選擇離所在地最近的載點，以臺灣桃園為例，可選擇元智大學 ( Department of Computer Science and Engineering, Yuan Ze University) 的載點。 進入下載網頁後，可看到多個選項: Download R for Linux Download R for (Mac) OS X Download R for Windows 依作業系統選擇適當連結後，點選base (Binaries for base distribution)，下載最新版本的R安裝檔。 Step 2. 依安裝檔指示完成安裝 12.2 RStudio安裝 RStudio是R語言的IDE，屬於免費自由軟體，提供一般桌面板與伺服器版，以下介紹桌面板安裝方式，伺服器版安裝可參考Chapter 11。 Step 1. 從RStudio的官網下載安裝檔 進入RStudio官網 https://www.rstudio.com/ 選擇網頁上方Products連結內的RStudio 選擇Desktop版本 點選Open Source Edition下方的DOWNLOAD RSTUDIO DESKTOP 點選RStudio Desktop Open Source License下方的DOWNLOAD 選單中會出現多種作業系統版本，以RStudio 1.0.136為例，各作業系統版本如下 RStudio 1.0.136 - Windows Vista/7/8/10 RStudio 1.0.136 - Mac OS X 10.6+ (64-bit) RStudio 1.0.136 - Ubuntu 12.04+/Debian 8+ (32-bit) RStudio 1.0.136 - Ubuntu 12.04+/Debian 8+ (64-bit) RStudio 1.0.136 - Fedora 19+/RedHat 7+/openSUSE 13.1+ (32-bit) RStudio 1.0.136 - Fedora 19+/RedHat 7+/openSUSE 13.1+ (64-bit) 依作業系統選擇適當連結 Step 2. 依安裝檔指示完成安裝 12.3 RStudio使用簡介 12.3.1 專案 RStudio引進專案(Project)的概念，幫助使用者管理同一專案之R程式碼檔案，同時完成工作路徑的設定 (設定為專案所在資料夾)。除快速測試外，建議一開始就以專案形式新增R程式碼。 以本課程為例，開啟RStudio視窗後，可在左上File選項中選擇New Project後，依需求選擇New Directory或Existing Directory 若選擇的是New Directory，則會出現下列三個選項 Empty Project R Package Shiny Web Application 若是新增一般分析專案，選擇Empty Project後，輸入專案路徑與專案名稱，完成專案新增。 完成專案新增後，在專案內新增R程式碼檔案(File -&gt; New file -&gt; R Script)後，程式碼編輯區 Source editor就會出現在左上角。 12.3.2 RStudio介面 RStudio的介面共有四個區塊，分別為 程式碼編輯區 Source editor 執行視窗 Console 環境/物件 檔案/圖表/說明文件 剛開啟一個新的RStudio視窗時不會有程式碼編輯區 Source editor，必須要新增專案後才會出現。 建議使用方式如下: 在左上方程式碼編輯區 Source editor撰寫程式碼 完成程式碼撰寫後，將需要執行的程式碼反白，點選Run (見下圖)，執行程式碼 除了反白外，將游標移至需要執行的程式碼，，點選Run (見下圖)也可執行該行程式碼 程式碼會在左下方Console視窗執行，顯示結果 如果有畫圖，會出現在右下方視窗 可在右上方視窗檢查所有變數 RStudio的其他使用細節，可參考RStudio IDE Cheat Sheet "],
["video.html", "13 教學影片資訊 13.1 教學影片頻道連結 13.2 完整版播放清單 13.3 速成版播放清單", " 13 教學影片資訊 13.1 教學影片頻道連結 資料科學與R語言 YouTube頻道 13.2 完整版播放清單 R 101 &amp; GitHub 101 - [資料科學與R語言] 資料結構 - [資料科學與R語言] 控制流程 - [資料科學與R語言] 資料讀取與匯出 - [資料科學與R語言] 資料處理與清洗 - [資料科學與R語言] 探索式資料分析 - [資料科學與R語言] 資料視覺化 - [資料科學與R語言] 資料探勘 - [資料科學與R語言] R Function and Package [資料科學與R語言] 13.3 速成版播放清單 R101與條件判斷 [R資料科學速成] 資料結構 [R資料科學速成] 資料匯入與匯出 [R資料科學速成] 資料處理與清洗 [R資料科學速成] 資料結合 [R資料科學速成] 探索式資料分析 [R資料科學速成] "],
["author.html", "作者資訊", " 作者資訊 曾意儒 Yi-Ju Tseng 長庚大學 資訊管理學系 副教授 個人網站 Lab: 數位健康實驗室 歡迎提供建議與回饋 "],
["references.html", "References", " References "]
]
